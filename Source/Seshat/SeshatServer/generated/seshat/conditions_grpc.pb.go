// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: seshat/conditions.proto

package seshat

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ConditionsService_ApplyCondition_FullMethodName           = "/seshat.ConditionsService/ApplyCondition"
	ConditionsService_RemoveCondition_FullMethodName          = "/seshat.ConditionsService/RemoveCondition"
	ConditionsService_GetConditions_FullMethodName            = "/seshat.ConditionsService/GetConditions"
	ConditionsService_UpdateCondition_FullMethodName          = "/seshat.ConditionsService/UpdateCondition"
	ConditionsService_HasCondition_FullMethodName             = "/seshat.ConditionsService/HasCondition"
	ConditionsService_GetConditionsByType_FullMethodName      = "/seshat.ConditionsService/GetConditionsByType"
	ConditionsService_GetActiveConditions_FullMethodName      = "/seshat.ConditionsService/GetActiveConditions"
	ConditionsService_CheckImmunity_FullMethodName            = "/seshat.ConditionsService/CheckImmunity"
	ConditionsService_GetConflictingConditions_FullMethodName = "/seshat.ConditionsService/GetConflictingConditions"
	ConditionsService_ResolveConflicts_FullMethodName         = "/seshat.ConditionsService/ResolveConflicts"
	ConditionsService_GetConditionTemplates_FullMethodName    = "/seshat.ConditionsService/GetConditionTemplates"
	ConditionsService_CreateConditionTemplate_FullMethodName  = "/seshat.ConditionsService/CreateConditionTemplate"
	ConditionsService_ProcessConditionTick_FullMethodName     = "/seshat.ConditionsService/ProcessConditionTick"
	ConditionsService_GetConditionHistory_FullMethodName      = "/seshat.ConditionsService/GetConditionHistory"
)

// ConditionsServiceClient is the client API for ConditionsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Conditions service - exposes all conditions toolkit functionality
type ConditionsServiceClient interface {
	// Condition management
	ApplyCondition(ctx context.Context, in *ApplyConditionRequest, opts ...grpc.CallOption) (*ApplyConditionResponse, error)
	RemoveCondition(ctx context.Context, in *RemoveConditionRequest, opts ...grpc.CallOption) (*RemoveConditionResponse, error)
	GetConditions(ctx context.Context, in *GetConditionsRequest, opts ...grpc.CallOption) (*GetConditionsResponse, error)
	UpdateCondition(ctx context.Context, in *UpdateConditionRequest, opts ...grpc.CallOption) (*UpdateConditionResponse, error)
	// Condition queries
	HasCondition(ctx context.Context, in *HasConditionRequest, opts ...grpc.CallOption) (*HasConditionResponse, error)
	GetConditionsByType(ctx context.Context, in *GetConditionsByTypeRequest, opts ...grpc.CallOption) (*GetConditionsByTypeResponse, error)
	GetActiveConditions(ctx context.Context, in *GetActiveConditionsRequest, opts ...grpc.CallOption) (*GetActiveConditionsResponse, error)
	// Condition relationships
	CheckImmunity(ctx context.Context, in *CheckImmunityRequest, opts ...grpc.CallOption) (*CheckImmunityResponse, error)
	GetConflictingConditions(ctx context.Context, in *GetConflictingConditionsRequest, opts ...grpc.CallOption) (*GetConflictingConditionsResponse, error)
	ResolveConflicts(ctx context.Context, in *ResolveConflictsRequest, opts ...grpc.CallOption) (*ResolveConflictsResponse, error)
	// Condition templates
	GetConditionTemplates(ctx context.Context, in *GetConditionTemplatesRequest, opts ...grpc.CallOption) (*GetConditionTemplatesResponse, error)
	CreateConditionTemplate(ctx context.Context, in *CreateConditionTemplateRequest, opts ...grpc.CallOption) (*CreateConditionTemplateResponse, error)
	// Advanced features
	ProcessConditionTick(ctx context.Context, in *ProcessConditionTickRequest, opts ...grpc.CallOption) (*ProcessConditionTickResponse, error)
	GetConditionHistory(ctx context.Context, in *GetConditionHistoryRequest, opts ...grpc.CallOption) (*GetConditionHistoryResponse, error)
}

type conditionsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConditionsServiceClient(cc grpc.ClientConnInterface) ConditionsServiceClient {
	return &conditionsServiceClient{cc}
}

func (c *conditionsServiceClient) ApplyCondition(ctx context.Context, in *ApplyConditionRequest, opts ...grpc.CallOption) (*ApplyConditionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApplyConditionResponse)
	err := c.cc.Invoke(ctx, ConditionsService_ApplyCondition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conditionsServiceClient) RemoveCondition(ctx context.Context, in *RemoveConditionRequest, opts ...grpc.CallOption) (*RemoveConditionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveConditionResponse)
	err := c.cc.Invoke(ctx, ConditionsService_RemoveCondition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conditionsServiceClient) GetConditions(ctx context.Context, in *GetConditionsRequest, opts ...grpc.CallOption) (*GetConditionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConditionsResponse)
	err := c.cc.Invoke(ctx, ConditionsService_GetConditions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conditionsServiceClient) UpdateCondition(ctx context.Context, in *UpdateConditionRequest, opts ...grpc.CallOption) (*UpdateConditionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateConditionResponse)
	err := c.cc.Invoke(ctx, ConditionsService_UpdateCondition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conditionsServiceClient) HasCondition(ctx context.Context, in *HasConditionRequest, opts ...grpc.CallOption) (*HasConditionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HasConditionResponse)
	err := c.cc.Invoke(ctx, ConditionsService_HasCondition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conditionsServiceClient) GetConditionsByType(ctx context.Context, in *GetConditionsByTypeRequest, opts ...grpc.CallOption) (*GetConditionsByTypeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConditionsByTypeResponse)
	err := c.cc.Invoke(ctx, ConditionsService_GetConditionsByType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conditionsServiceClient) GetActiveConditions(ctx context.Context, in *GetActiveConditionsRequest, opts ...grpc.CallOption) (*GetActiveConditionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActiveConditionsResponse)
	err := c.cc.Invoke(ctx, ConditionsService_GetActiveConditions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conditionsServiceClient) CheckImmunity(ctx context.Context, in *CheckImmunityRequest, opts ...grpc.CallOption) (*CheckImmunityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckImmunityResponse)
	err := c.cc.Invoke(ctx, ConditionsService_CheckImmunity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conditionsServiceClient) GetConflictingConditions(ctx context.Context, in *GetConflictingConditionsRequest, opts ...grpc.CallOption) (*GetConflictingConditionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConflictingConditionsResponse)
	err := c.cc.Invoke(ctx, ConditionsService_GetConflictingConditions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conditionsServiceClient) ResolveConflicts(ctx context.Context, in *ResolveConflictsRequest, opts ...grpc.CallOption) (*ResolveConflictsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResolveConflictsResponse)
	err := c.cc.Invoke(ctx, ConditionsService_ResolveConflicts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conditionsServiceClient) GetConditionTemplates(ctx context.Context, in *GetConditionTemplatesRequest, opts ...grpc.CallOption) (*GetConditionTemplatesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConditionTemplatesResponse)
	err := c.cc.Invoke(ctx, ConditionsService_GetConditionTemplates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conditionsServiceClient) CreateConditionTemplate(ctx context.Context, in *CreateConditionTemplateRequest, opts ...grpc.CallOption) (*CreateConditionTemplateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateConditionTemplateResponse)
	err := c.cc.Invoke(ctx, ConditionsService_CreateConditionTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conditionsServiceClient) ProcessConditionTick(ctx context.Context, in *ProcessConditionTickRequest, opts ...grpc.CallOption) (*ProcessConditionTickResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessConditionTickResponse)
	err := c.cc.Invoke(ctx, ConditionsService_ProcessConditionTick_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *conditionsServiceClient) GetConditionHistory(ctx context.Context, in *GetConditionHistoryRequest, opts ...grpc.CallOption) (*GetConditionHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConditionHistoryResponse)
	err := c.cc.Invoke(ctx, ConditionsService_GetConditionHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConditionsServiceServer is the server API for ConditionsService service.
// All implementations must embed UnimplementedConditionsServiceServer
// for forward compatibility.
//
// Conditions service - exposes all conditions toolkit functionality
type ConditionsServiceServer interface {
	// Condition management
	ApplyCondition(context.Context, *ApplyConditionRequest) (*ApplyConditionResponse, error)
	RemoveCondition(context.Context, *RemoveConditionRequest) (*RemoveConditionResponse, error)
	GetConditions(context.Context, *GetConditionsRequest) (*GetConditionsResponse, error)
	UpdateCondition(context.Context, *UpdateConditionRequest) (*UpdateConditionResponse, error)
	// Condition queries
	HasCondition(context.Context, *HasConditionRequest) (*HasConditionResponse, error)
	GetConditionsByType(context.Context, *GetConditionsByTypeRequest) (*GetConditionsByTypeResponse, error)
	GetActiveConditions(context.Context, *GetActiveConditionsRequest) (*GetActiveConditionsResponse, error)
	// Condition relationships
	CheckImmunity(context.Context, *CheckImmunityRequest) (*CheckImmunityResponse, error)
	GetConflictingConditions(context.Context, *GetConflictingConditionsRequest) (*GetConflictingConditionsResponse, error)
	ResolveConflicts(context.Context, *ResolveConflictsRequest) (*ResolveConflictsResponse, error)
	// Condition templates
	GetConditionTemplates(context.Context, *GetConditionTemplatesRequest) (*GetConditionTemplatesResponse, error)
	CreateConditionTemplate(context.Context, *CreateConditionTemplateRequest) (*CreateConditionTemplateResponse, error)
	// Advanced features
	ProcessConditionTick(context.Context, *ProcessConditionTickRequest) (*ProcessConditionTickResponse, error)
	GetConditionHistory(context.Context, *GetConditionHistoryRequest) (*GetConditionHistoryResponse, error)
	mustEmbedUnimplementedConditionsServiceServer()
}

// UnimplementedConditionsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConditionsServiceServer struct{}

func (UnimplementedConditionsServiceServer) ApplyCondition(context.Context, *ApplyConditionRequest) (*ApplyConditionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyCondition not implemented")
}
func (UnimplementedConditionsServiceServer) RemoveCondition(context.Context, *RemoveConditionRequest) (*RemoveConditionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveCondition not implemented")
}
func (UnimplementedConditionsServiceServer) GetConditions(context.Context, *GetConditionsRequest) (*GetConditionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConditions not implemented")
}
func (UnimplementedConditionsServiceServer) UpdateCondition(context.Context, *UpdateConditionRequest) (*UpdateConditionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCondition not implemented")
}
func (UnimplementedConditionsServiceServer) HasCondition(context.Context, *HasConditionRequest) (*HasConditionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasCondition not implemented")
}
func (UnimplementedConditionsServiceServer) GetConditionsByType(context.Context, *GetConditionsByTypeRequest) (*GetConditionsByTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConditionsByType not implemented")
}
func (UnimplementedConditionsServiceServer) GetActiveConditions(context.Context, *GetActiveConditionsRequest) (*GetActiveConditionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveConditions not implemented")
}
func (UnimplementedConditionsServiceServer) CheckImmunity(context.Context, *CheckImmunityRequest) (*CheckImmunityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckImmunity not implemented")
}
func (UnimplementedConditionsServiceServer) GetConflictingConditions(context.Context, *GetConflictingConditionsRequest) (*GetConflictingConditionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConflictingConditions not implemented")
}
func (UnimplementedConditionsServiceServer) ResolveConflicts(context.Context, *ResolveConflictsRequest) (*ResolveConflictsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveConflicts not implemented")
}
func (UnimplementedConditionsServiceServer) GetConditionTemplates(context.Context, *GetConditionTemplatesRequest) (*GetConditionTemplatesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConditionTemplates not implemented")
}
func (UnimplementedConditionsServiceServer) CreateConditionTemplate(context.Context, *CreateConditionTemplateRequest) (*CreateConditionTemplateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateConditionTemplate not implemented")
}
func (UnimplementedConditionsServiceServer) ProcessConditionTick(context.Context, *ProcessConditionTickRequest) (*ProcessConditionTickResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessConditionTick not implemented")
}
func (UnimplementedConditionsServiceServer) GetConditionHistory(context.Context, *GetConditionHistoryRequest) (*GetConditionHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConditionHistory not implemented")
}
func (UnimplementedConditionsServiceServer) mustEmbedUnimplementedConditionsServiceServer() {}
func (UnimplementedConditionsServiceServer) testEmbeddedByValue()                           {}

// UnsafeConditionsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConditionsServiceServer will
// result in compilation errors.
type UnsafeConditionsServiceServer interface {
	mustEmbedUnimplementedConditionsServiceServer()
}

func RegisterConditionsServiceServer(s grpc.ServiceRegistrar, srv ConditionsServiceServer) {
	// If the following call pancis, it indicates UnimplementedConditionsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConditionsService_ServiceDesc, srv)
}

func _ConditionsService_ApplyCondition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyConditionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConditionsServiceServer).ApplyCondition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConditionsService_ApplyCondition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConditionsServiceServer).ApplyCondition(ctx, req.(*ApplyConditionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConditionsService_RemoveCondition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveConditionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConditionsServiceServer).RemoveCondition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConditionsService_RemoveCondition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConditionsServiceServer).RemoveCondition(ctx, req.(*RemoveConditionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConditionsService_GetConditions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConditionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConditionsServiceServer).GetConditions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConditionsService_GetConditions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConditionsServiceServer).GetConditions(ctx, req.(*GetConditionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConditionsService_UpdateCondition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateConditionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConditionsServiceServer).UpdateCondition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConditionsService_UpdateCondition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConditionsServiceServer).UpdateCondition(ctx, req.(*UpdateConditionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConditionsService_HasCondition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HasConditionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConditionsServiceServer).HasCondition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConditionsService_HasCondition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConditionsServiceServer).HasCondition(ctx, req.(*HasConditionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConditionsService_GetConditionsByType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConditionsByTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConditionsServiceServer).GetConditionsByType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConditionsService_GetConditionsByType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConditionsServiceServer).GetConditionsByType(ctx, req.(*GetConditionsByTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConditionsService_GetActiveConditions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActiveConditionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConditionsServiceServer).GetActiveConditions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConditionsService_GetActiveConditions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConditionsServiceServer).GetActiveConditions(ctx, req.(*GetActiveConditionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConditionsService_CheckImmunity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckImmunityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConditionsServiceServer).CheckImmunity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConditionsService_CheckImmunity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConditionsServiceServer).CheckImmunity(ctx, req.(*CheckImmunityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConditionsService_GetConflictingConditions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConflictingConditionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConditionsServiceServer).GetConflictingConditions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConditionsService_GetConflictingConditions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConditionsServiceServer).GetConflictingConditions(ctx, req.(*GetConflictingConditionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConditionsService_ResolveConflicts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveConflictsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConditionsServiceServer).ResolveConflicts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConditionsService_ResolveConflicts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConditionsServiceServer).ResolveConflicts(ctx, req.(*ResolveConflictsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConditionsService_GetConditionTemplates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConditionTemplatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConditionsServiceServer).GetConditionTemplates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConditionsService_GetConditionTemplates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConditionsServiceServer).GetConditionTemplates(ctx, req.(*GetConditionTemplatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConditionsService_CreateConditionTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateConditionTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConditionsServiceServer).CreateConditionTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConditionsService_CreateConditionTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConditionsServiceServer).CreateConditionTemplate(ctx, req.(*CreateConditionTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConditionsService_ProcessConditionTick_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessConditionTickRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConditionsServiceServer).ProcessConditionTick(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConditionsService_ProcessConditionTick_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConditionsServiceServer).ProcessConditionTick(ctx, req.(*ProcessConditionTickRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConditionsService_GetConditionHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConditionHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConditionsServiceServer).GetConditionHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConditionsService_GetConditionHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConditionsServiceServer).GetConditionHistory(ctx, req.(*GetConditionHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ConditionsService_ServiceDesc is the grpc.ServiceDesc for ConditionsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConditionsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "seshat.ConditionsService",
	HandlerType: (*ConditionsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ApplyCondition",
			Handler:    _ConditionsService_ApplyCondition_Handler,
		},
		{
			MethodName: "RemoveCondition",
			Handler:    _ConditionsService_RemoveCondition_Handler,
		},
		{
			MethodName: "GetConditions",
			Handler:    _ConditionsService_GetConditions_Handler,
		},
		{
			MethodName: "UpdateCondition",
			Handler:    _ConditionsService_UpdateCondition_Handler,
		},
		{
			MethodName: "HasCondition",
			Handler:    _ConditionsService_HasCondition_Handler,
		},
		{
			MethodName: "GetConditionsByType",
			Handler:    _ConditionsService_GetConditionsByType_Handler,
		},
		{
			MethodName: "GetActiveConditions",
			Handler:    _ConditionsService_GetActiveConditions_Handler,
		},
		{
			MethodName: "CheckImmunity",
			Handler:    _ConditionsService_CheckImmunity_Handler,
		},
		{
			MethodName: "GetConflictingConditions",
			Handler:    _ConditionsService_GetConflictingConditions_Handler,
		},
		{
			MethodName: "ResolveConflicts",
			Handler:    _ConditionsService_ResolveConflicts_Handler,
		},
		{
			MethodName: "GetConditionTemplates",
			Handler:    _ConditionsService_GetConditionTemplates_Handler,
		},
		{
			MethodName: "CreateConditionTemplate",
			Handler:    _ConditionsService_CreateConditionTemplate_Handler,
		},
		{
			MethodName: "ProcessConditionTick",
			Handler:    _ConditionsService_ProcessConditionTick_Handler,
		},
		{
			MethodName: "GetConditionHistory",
			Handler:    _ConditionsService_GetConditionHistory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "seshat/conditions.proto",
}
