// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: seshat/conditions.proto
#ifndef GRPC_seshat_2fconditions_2eproto__INCLUDED
#define GRPC_seshat_2fconditions_2eproto__INCLUDED

#include "seshat/conditions.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace seshat {

// Conditions service - exposes all conditions toolkit functionality
class ConditionsService final {
 public:
  static constexpr char const* service_full_name() {
    return "seshat.ConditionsService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Condition management
    virtual ::grpc::Status ApplyCondition(::grpc::ClientContext* context, const ::seshat::ApplyConditionRequest& request, ::seshat::ApplyConditionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ApplyConditionResponse>> AsyncApplyCondition(::grpc::ClientContext* context, const ::seshat::ApplyConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ApplyConditionResponse>>(AsyncApplyConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ApplyConditionResponse>> PrepareAsyncApplyCondition(::grpc::ClientContext* context, const ::seshat::ApplyConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ApplyConditionResponse>>(PrepareAsyncApplyConditionRaw(context, request, cq));
    }
    virtual ::grpc::Status RemoveCondition(::grpc::ClientContext* context, const ::seshat::RemoveConditionRequest& request, ::seshat::RemoveConditionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RemoveConditionResponse>> AsyncRemoveCondition(::grpc::ClientContext* context, const ::seshat::RemoveConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RemoveConditionResponse>>(AsyncRemoveConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RemoveConditionResponse>> PrepareAsyncRemoveCondition(::grpc::ClientContext* context, const ::seshat::RemoveConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RemoveConditionResponse>>(PrepareAsyncRemoveConditionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetConditions(::grpc::ClientContext* context, const ::seshat::GetConditionsRequest& request, ::seshat::GetConditionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionsResponse>> AsyncGetConditions(::grpc::ClientContext* context, const ::seshat::GetConditionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionsResponse>>(AsyncGetConditionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionsResponse>> PrepareAsyncGetConditions(::grpc::ClientContext* context, const ::seshat::GetConditionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionsResponse>>(PrepareAsyncGetConditionsRaw(context, request, cq));
    }
    virtual ::grpc::Status UpdateCondition(::grpc::ClientContext* context, const ::seshat::UpdateConditionRequest& request, ::seshat::UpdateConditionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UpdateConditionResponse>> AsyncUpdateCondition(::grpc::ClientContext* context, const ::seshat::UpdateConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UpdateConditionResponse>>(AsyncUpdateConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UpdateConditionResponse>> PrepareAsyncUpdateCondition(::grpc::ClientContext* context, const ::seshat::UpdateConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UpdateConditionResponse>>(PrepareAsyncUpdateConditionRaw(context, request, cq));
    }
    // Condition queries
    virtual ::grpc::Status HasCondition(::grpc::ClientContext* context, const ::seshat::HasConditionRequest& request, ::seshat::HasConditionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::HasConditionResponse>> AsyncHasCondition(::grpc::ClientContext* context, const ::seshat::HasConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::HasConditionResponse>>(AsyncHasConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::HasConditionResponse>> PrepareAsyncHasCondition(::grpc::ClientContext* context, const ::seshat::HasConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::HasConditionResponse>>(PrepareAsyncHasConditionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetConditionsByType(::grpc::ClientContext* context, const ::seshat::GetConditionsByTypeRequest& request, ::seshat::GetConditionsByTypeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionsByTypeResponse>> AsyncGetConditionsByType(::grpc::ClientContext* context, const ::seshat::GetConditionsByTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionsByTypeResponse>>(AsyncGetConditionsByTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionsByTypeResponse>> PrepareAsyncGetConditionsByType(::grpc::ClientContext* context, const ::seshat::GetConditionsByTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionsByTypeResponse>>(PrepareAsyncGetConditionsByTypeRaw(context, request, cq));
    }
    virtual ::grpc::Status GetActiveConditions(::grpc::ClientContext* context, const ::seshat::GetActiveConditionsRequest& request, ::seshat::GetActiveConditionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetActiveConditionsResponse>> AsyncGetActiveConditions(::grpc::ClientContext* context, const ::seshat::GetActiveConditionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetActiveConditionsResponse>>(AsyncGetActiveConditionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetActiveConditionsResponse>> PrepareAsyncGetActiveConditions(::grpc::ClientContext* context, const ::seshat::GetActiveConditionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetActiveConditionsResponse>>(PrepareAsyncGetActiveConditionsRaw(context, request, cq));
    }
    // Condition relationships
    virtual ::grpc::Status CheckImmunity(::grpc::ClientContext* context, const ::seshat::CheckImmunityRequest& request, ::seshat::CheckImmunityResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CheckImmunityResponse>> AsyncCheckImmunity(::grpc::ClientContext* context, const ::seshat::CheckImmunityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CheckImmunityResponse>>(AsyncCheckImmunityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CheckImmunityResponse>> PrepareAsyncCheckImmunity(::grpc::ClientContext* context, const ::seshat::CheckImmunityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CheckImmunityResponse>>(PrepareAsyncCheckImmunityRaw(context, request, cq));
    }
    virtual ::grpc::Status GetConflictingConditions(::grpc::ClientContext* context, const ::seshat::GetConflictingConditionsRequest& request, ::seshat::GetConflictingConditionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConflictingConditionsResponse>> AsyncGetConflictingConditions(::grpc::ClientContext* context, const ::seshat::GetConflictingConditionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConflictingConditionsResponse>>(AsyncGetConflictingConditionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConflictingConditionsResponse>> PrepareAsyncGetConflictingConditions(::grpc::ClientContext* context, const ::seshat::GetConflictingConditionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConflictingConditionsResponse>>(PrepareAsyncGetConflictingConditionsRaw(context, request, cq));
    }
    virtual ::grpc::Status ResolveConflicts(::grpc::ClientContext* context, const ::seshat::ResolveConflictsRequest& request, ::seshat::ResolveConflictsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ResolveConflictsResponse>> AsyncResolveConflicts(::grpc::ClientContext* context, const ::seshat::ResolveConflictsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ResolveConflictsResponse>>(AsyncResolveConflictsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ResolveConflictsResponse>> PrepareAsyncResolveConflicts(::grpc::ClientContext* context, const ::seshat::ResolveConflictsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ResolveConflictsResponse>>(PrepareAsyncResolveConflictsRaw(context, request, cq));
    }
    // Condition templates
    virtual ::grpc::Status GetConditionTemplates(::grpc::ClientContext* context, const ::seshat::GetConditionTemplatesRequest& request, ::seshat::GetConditionTemplatesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionTemplatesResponse>> AsyncGetConditionTemplates(::grpc::ClientContext* context, const ::seshat::GetConditionTemplatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionTemplatesResponse>>(AsyncGetConditionTemplatesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionTemplatesResponse>> PrepareAsyncGetConditionTemplates(::grpc::ClientContext* context, const ::seshat::GetConditionTemplatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionTemplatesResponse>>(PrepareAsyncGetConditionTemplatesRaw(context, request, cq));
    }
    virtual ::grpc::Status CreateConditionTemplate(::grpc::ClientContext* context, const ::seshat::CreateConditionTemplateRequest& request, ::seshat::CreateConditionTemplateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateConditionTemplateResponse>> AsyncCreateConditionTemplate(::grpc::ClientContext* context, const ::seshat::CreateConditionTemplateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateConditionTemplateResponse>>(AsyncCreateConditionTemplateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateConditionTemplateResponse>> PrepareAsyncCreateConditionTemplate(::grpc::ClientContext* context, const ::seshat::CreateConditionTemplateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateConditionTemplateResponse>>(PrepareAsyncCreateConditionTemplateRaw(context, request, cq));
    }
    // Advanced features
    virtual ::grpc::Status ProcessConditionTick(::grpc::ClientContext* context, const ::seshat::ProcessConditionTickRequest& request, ::seshat::ProcessConditionTickResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ProcessConditionTickResponse>> AsyncProcessConditionTick(::grpc::ClientContext* context, const ::seshat::ProcessConditionTickRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ProcessConditionTickResponse>>(AsyncProcessConditionTickRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ProcessConditionTickResponse>> PrepareAsyncProcessConditionTick(::grpc::ClientContext* context, const ::seshat::ProcessConditionTickRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ProcessConditionTickResponse>>(PrepareAsyncProcessConditionTickRaw(context, request, cq));
    }
    virtual ::grpc::Status GetConditionHistory(::grpc::ClientContext* context, const ::seshat::GetConditionHistoryRequest& request, ::seshat::GetConditionHistoryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionHistoryResponse>> AsyncGetConditionHistory(::grpc::ClientContext* context, const ::seshat::GetConditionHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionHistoryResponse>>(AsyncGetConditionHistoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionHistoryResponse>> PrepareAsyncGetConditionHistory(::grpc::ClientContext* context, const ::seshat::GetConditionHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionHistoryResponse>>(PrepareAsyncGetConditionHistoryRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Condition management
      virtual void ApplyCondition(::grpc::ClientContext* context, const ::seshat::ApplyConditionRequest* request, ::seshat::ApplyConditionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ApplyCondition(::grpc::ClientContext* context, const ::seshat::ApplyConditionRequest* request, ::seshat::ApplyConditionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void RemoveCondition(::grpc::ClientContext* context, const ::seshat::RemoveConditionRequest* request, ::seshat::RemoveConditionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RemoveCondition(::grpc::ClientContext* context, const ::seshat::RemoveConditionRequest* request, ::seshat::RemoveConditionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetConditions(::grpc::ClientContext* context, const ::seshat::GetConditionsRequest* request, ::seshat::GetConditionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetConditions(::grpc::ClientContext* context, const ::seshat::GetConditionsRequest* request, ::seshat::GetConditionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateCondition(::grpc::ClientContext* context, const ::seshat::UpdateConditionRequest* request, ::seshat::UpdateConditionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateCondition(::grpc::ClientContext* context, const ::seshat::UpdateConditionRequest* request, ::seshat::UpdateConditionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Condition queries
      virtual void HasCondition(::grpc::ClientContext* context, const ::seshat::HasConditionRequest* request, ::seshat::HasConditionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HasCondition(::grpc::ClientContext* context, const ::seshat::HasConditionRequest* request, ::seshat::HasConditionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetConditionsByType(::grpc::ClientContext* context, const ::seshat::GetConditionsByTypeRequest* request, ::seshat::GetConditionsByTypeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetConditionsByType(::grpc::ClientContext* context, const ::seshat::GetConditionsByTypeRequest* request, ::seshat::GetConditionsByTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetActiveConditions(::grpc::ClientContext* context, const ::seshat::GetActiveConditionsRequest* request, ::seshat::GetActiveConditionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetActiveConditions(::grpc::ClientContext* context, const ::seshat::GetActiveConditionsRequest* request, ::seshat::GetActiveConditionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Condition relationships
      virtual void CheckImmunity(::grpc::ClientContext* context, const ::seshat::CheckImmunityRequest* request, ::seshat::CheckImmunityResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckImmunity(::grpc::ClientContext* context, const ::seshat::CheckImmunityRequest* request, ::seshat::CheckImmunityResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetConflictingConditions(::grpc::ClientContext* context, const ::seshat::GetConflictingConditionsRequest* request, ::seshat::GetConflictingConditionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetConflictingConditions(::grpc::ClientContext* context, const ::seshat::GetConflictingConditionsRequest* request, ::seshat::GetConflictingConditionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ResolveConflicts(::grpc::ClientContext* context, const ::seshat::ResolveConflictsRequest* request, ::seshat::ResolveConflictsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResolveConflicts(::grpc::ClientContext* context, const ::seshat::ResolveConflictsRequest* request, ::seshat::ResolveConflictsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Condition templates
      virtual void GetConditionTemplates(::grpc::ClientContext* context, const ::seshat::GetConditionTemplatesRequest* request, ::seshat::GetConditionTemplatesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetConditionTemplates(::grpc::ClientContext* context, const ::seshat::GetConditionTemplatesRequest* request, ::seshat::GetConditionTemplatesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CreateConditionTemplate(::grpc::ClientContext* context, const ::seshat::CreateConditionTemplateRequest* request, ::seshat::CreateConditionTemplateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateConditionTemplate(::grpc::ClientContext* context, const ::seshat::CreateConditionTemplateRequest* request, ::seshat::CreateConditionTemplateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Advanced features
      virtual void ProcessConditionTick(::grpc::ClientContext* context, const ::seshat::ProcessConditionTickRequest* request, ::seshat::ProcessConditionTickResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ProcessConditionTick(::grpc::ClientContext* context, const ::seshat::ProcessConditionTickRequest* request, ::seshat::ProcessConditionTickResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetConditionHistory(::grpc::ClientContext* context, const ::seshat::GetConditionHistoryRequest* request, ::seshat::GetConditionHistoryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetConditionHistory(::grpc::ClientContext* context, const ::seshat::GetConditionHistoryRequest* request, ::seshat::GetConditionHistoryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ApplyConditionResponse>* AsyncApplyConditionRaw(::grpc::ClientContext* context, const ::seshat::ApplyConditionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ApplyConditionResponse>* PrepareAsyncApplyConditionRaw(::grpc::ClientContext* context, const ::seshat::ApplyConditionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RemoveConditionResponse>* AsyncRemoveConditionRaw(::grpc::ClientContext* context, const ::seshat::RemoveConditionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RemoveConditionResponse>* PrepareAsyncRemoveConditionRaw(::grpc::ClientContext* context, const ::seshat::RemoveConditionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionsResponse>* AsyncGetConditionsRaw(::grpc::ClientContext* context, const ::seshat::GetConditionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionsResponse>* PrepareAsyncGetConditionsRaw(::grpc::ClientContext* context, const ::seshat::GetConditionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UpdateConditionResponse>* AsyncUpdateConditionRaw(::grpc::ClientContext* context, const ::seshat::UpdateConditionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UpdateConditionResponse>* PrepareAsyncUpdateConditionRaw(::grpc::ClientContext* context, const ::seshat::UpdateConditionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::HasConditionResponse>* AsyncHasConditionRaw(::grpc::ClientContext* context, const ::seshat::HasConditionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::HasConditionResponse>* PrepareAsyncHasConditionRaw(::grpc::ClientContext* context, const ::seshat::HasConditionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionsByTypeResponse>* AsyncGetConditionsByTypeRaw(::grpc::ClientContext* context, const ::seshat::GetConditionsByTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionsByTypeResponse>* PrepareAsyncGetConditionsByTypeRaw(::grpc::ClientContext* context, const ::seshat::GetConditionsByTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetActiveConditionsResponse>* AsyncGetActiveConditionsRaw(::grpc::ClientContext* context, const ::seshat::GetActiveConditionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetActiveConditionsResponse>* PrepareAsyncGetActiveConditionsRaw(::grpc::ClientContext* context, const ::seshat::GetActiveConditionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CheckImmunityResponse>* AsyncCheckImmunityRaw(::grpc::ClientContext* context, const ::seshat::CheckImmunityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CheckImmunityResponse>* PrepareAsyncCheckImmunityRaw(::grpc::ClientContext* context, const ::seshat::CheckImmunityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConflictingConditionsResponse>* AsyncGetConflictingConditionsRaw(::grpc::ClientContext* context, const ::seshat::GetConflictingConditionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConflictingConditionsResponse>* PrepareAsyncGetConflictingConditionsRaw(::grpc::ClientContext* context, const ::seshat::GetConflictingConditionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ResolveConflictsResponse>* AsyncResolveConflictsRaw(::grpc::ClientContext* context, const ::seshat::ResolveConflictsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ResolveConflictsResponse>* PrepareAsyncResolveConflictsRaw(::grpc::ClientContext* context, const ::seshat::ResolveConflictsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionTemplatesResponse>* AsyncGetConditionTemplatesRaw(::grpc::ClientContext* context, const ::seshat::GetConditionTemplatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionTemplatesResponse>* PrepareAsyncGetConditionTemplatesRaw(::grpc::ClientContext* context, const ::seshat::GetConditionTemplatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateConditionTemplateResponse>* AsyncCreateConditionTemplateRaw(::grpc::ClientContext* context, const ::seshat::CreateConditionTemplateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateConditionTemplateResponse>* PrepareAsyncCreateConditionTemplateRaw(::grpc::ClientContext* context, const ::seshat::CreateConditionTemplateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ProcessConditionTickResponse>* AsyncProcessConditionTickRaw(::grpc::ClientContext* context, const ::seshat::ProcessConditionTickRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ProcessConditionTickResponse>* PrepareAsyncProcessConditionTickRaw(::grpc::ClientContext* context, const ::seshat::ProcessConditionTickRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionHistoryResponse>* AsyncGetConditionHistoryRaw(::grpc::ClientContext* context, const ::seshat::GetConditionHistoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetConditionHistoryResponse>* PrepareAsyncGetConditionHistoryRaw(::grpc::ClientContext* context, const ::seshat::GetConditionHistoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status ApplyCondition(::grpc::ClientContext* context, const ::seshat::ApplyConditionRequest& request, ::seshat::ApplyConditionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ApplyConditionResponse>> AsyncApplyCondition(::grpc::ClientContext* context, const ::seshat::ApplyConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ApplyConditionResponse>>(AsyncApplyConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ApplyConditionResponse>> PrepareAsyncApplyCondition(::grpc::ClientContext* context, const ::seshat::ApplyConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ApplyConditionResponse>>(PrepareAsyncApplyConditionRaw(context, request, cq));
    }
    ::grpc::Status RemoveCondition(::grpc::ClientContext* context, const ::seshat::RemoveConditionRequest& request, ::seshat::RemoveConditionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::RemoveConditionResponse>> AsyncRemoveCondition(::grpc::ClientContext* context, const ::seshat::RemoveConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::RemoveConditionResponse>>(AsyncRemoveConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::RemoveConditionResponse>> PrepareAsyncRemoveCondition(::grpc::ClientContext* context, const ::seshat::RemoveConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::RemoveConditionResponse>>(PrepareAsyncRemoveConditionRaw(context, request, cq));
    }
    ::grpc::Status GetConditions(::grpc::ClientContext* context, const ::seshat::GetConditionsRequest& request, ::seshat::GetConditionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionsResponse>> AsyncGetConditions(::grpc::ClientContext* context, const ::seshat::GetConditionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionsResponse>>(AsyncGetConditionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionsResponse>> PrepareAsyncGetConditions(::grpc::ClientContext* context, const ::seshat::GetConditionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionsResponse>>(PrepareAsyncGetConditionsRaw(context, request, cq));
    }
    ::grpc::Status UpdateCondition(::grpc::ClientContext* context, const ::seshat::UpdateConditionRequest& request, ::seshat::UpdateConditionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::UpdateConditionResponse>> AsyncUpdateCondition(::grpc::ClientContext* context, const ::seshat::UpdateConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::UpdateConditionResponse>>(AsyncUpdateConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::UpdateConditionResponse>> PrepareAsyncUpdateCondition(::grpc::ClientContext* context, const ::seshat::UpdateConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::UpdateConditionResponse>>(PrepareAsyncUpdateConditionRaw(context, request, cq));
    }
    ::grpc::Status HasCondition(::grpc::ClientContext* context, const ::seshat::HasConditionRequest& request, ::seshat::HasConditionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::HasConditionResponse>> AsyncHasCondition(::grpc::ClientContext* context, const ::seshat::HasConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::HasConditionResponse>>(AsyncHasConditionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::HasConditionResponse>> PrepareAsyncHasCondition(::grpc::ClientContext* context, const ::seshat::HasConditionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::HasConditionResponse>>(PrepareAsyncHasConditionRaw(context, request, cq));
    }
    ::grpc::Status GetConditionsByType(::grpc::ClientContext* context, const ::seshat::GetConditionsByTypeRequest& request, ::seshat::GetConditionsByTypeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionsByTypeResponse>> AsyncGetConditionsByType(::grpc::ClientContext* context, const ::seshat::GetConditionsByTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionsByTypeResponse>>(AsyncGetConditionsByTypeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionsByTypeResponse>> PrepareAsyncGetConditionsByType(::grpc::ClientContext* context, const ::seshat::GetConditionsByTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionsByTypeResponse>>(PrepareAsyncGetConditionsByTypeRaw(context, request, cq));
    }
    ::grpc::Status GetActiveConditions(::grpc::ClientContext* context, const ::seshat::GetActiveConditionsRequest& request, ::seshat::GetActiveConditionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetActiveConditionsResponse>> AsyncGetActiveConditions(::grpc::ClientContext* context, const ::seshat::GetActiveConditionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetActiveConditionsResponse>>(AsyncGetActiveConditionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetActiveConditionsResponse>> PrepareAsyncGetActiveConditions(::grpc::ClientContext* context, const ::seshat::GetActiveConditionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetActiveConditionsResponse>>(PrepareAsyncGetActiveConditionsRaw(context, request, cq));
    }
    ::grpc::Status CheckImmunity(::grpc::ClientContext* context, const ::seshat::CheckImmunityRequest& request, ::seshat::CheckImmunityResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CheckImmunityResponse>> AsyncCheckImmunity(::grpc::ClientContext* context, const ::seshat::CheckImmunityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CheckImmunityResponse>>(AsyncCheckImmunityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CheckImmunityResponse>> PrepareAsyncCheckImmunity(::grpc::ClientContext* context, const ::seshat::CheckImmunityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CheckImmunityResponse>>(PrepareAsyncCheckImmunityRaw(context, request, cq));
    }
    ::grpc::Status GetConflictingConditions(::grpc::ClientContext* context, const ::seshat::GetConflictingConditionsRequest& request, ::seshat::GetConflictingConditionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConflictingConditionsResponse>> AsyncGetConflictingConditions(::grpc::ClientContext* context, const ::seshat::GetConflictingConditionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConflictingConditionsResponse>>(AsyncGetConflictingConditionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConflictingConditionsResponse>> PrepareAsyncGetConflictingConditions(::grpc::ClientContext* context, const ::seshat::GetConflictingConditionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConflictingConditionsResponse>>(PrepareAsyncGetConflictingConditionsRaw(context, request, cq));
    }
    ::grpc::Status ResolveConflicts(::grpc::ClientContext* context, const ::seshat::ResolveConflictsRequest& request, ::seshat::ResolveConflictsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ResolveConflictsResponse>> AsyncResolveConflicts(::grpc::ClientContext* context, const ::seshat::ResolveConflictsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ResolveConflictsResponse>>(AsyncResolveConflictsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ResolveConflictsResponse>> PrepareAsyncResolveConflicts(::grpc::ClientContext* context, const ::seshat::ResolveConflictsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ResolveConflictsResponse>>(PrepareAsyncResolveConflictsRaw(context, request, cq));
    }
    ::grpc::Status GetConditionTemplates(::grpc::ClientContext* context, const ::seshat::GetConditionTemplatesRequest& request, ::seshat::GetConditionTemplatesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionTemplatesResponse>> AsyncGetConditionTemplates(::grpc::ClientContext* context, const ::seshat::GetConditionTemplatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionTemplatesResponse>>(AsyncGetConditionTemplatesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionTemplatesResponse>> PrepareAsyncGetConditionTemplates(::grpc::ClientContext* context, const ::seshat::GetConditionTemplatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionTemplatesResponse>>(PrepareAsyncGetConditionTemplatesRaw(context, request, cq));
    }
    ::grpc::Status CreateConditionTemplate(::grpc::ClientContext* context, const ::seshat::CreateConditionTemplateRequest& request, ::seshat::CreateConditionTemplateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CreateConditionTemplateResponse>> AsyncCreateConditionTemplate(::grpc::ClientContext* context, const ::seshat::CreateConditionTemplateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CreateConditionTemplateResponse>>(AsyncCreateConditionTemplateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CreateConditionTemplateResponse>> PrepareAsyncCreateConditionTemplate(::grpc::ClientContext* context, const ::seshat::CreateConditionTemplateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CreateConditionTemplateResponse>>(PrepareAsyncCreateConditionTemplateRaw(context, request, cq));
    }
    ::grpc::Status ProcessConditionTick(::grpc::ClientContext* context, const ::seshat::ProcessConditionTickRequest& request, ::seshat::ProcessConditionTickResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ProcessConditionTickResponse>> AsyncProcessConditionTick(::grpc::ClientContext* context, const ::seshat::ProcessConditionTickRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ProcessConditionTickResponse>>(AsyncProcessConditionTickRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ProcessConditionTickResponse>> PrepareAsyncProcessConditionTick(::grpc::ClientContext* context, const ::seshat::ProcessConditionTickRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ProcessConditionTickResponse>>(PrepareAsyncProcessConditionTickRaw(context, request, cq));
    }
    ::grpc::Status GetConditionHistory(::grpc::ClientContext* context, const ::seshat::GetConditionHistoryRequest& request, ::seshat::GetConditionHistoryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionHistoryResponse>> AsyncGetConditionHistory(::grpc::ClientContext* context, const ::seshat::GetConditionHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionHistoryResponse>>(AsyncGetConditionHistoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionHistoryResponse>> PrepareAsyncGetConditionHistory(::grpc::ClientContext* context, const ::seshat::GetConditionHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionHistoryResponse>>(PrepareAsyncGetConditionHistoryRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void ApplyCondition(::grpc::ClientContext* context, const ::seshat::ApplyConditionRequest* request, ::seshat::ApplyConditionResponse* response, std::function<void(::grpc::Status)>) override;
      void ApplyCondition(::grpc::ClientContext* context, const ::seshat::ApplyConditionRequest* request, ::seshat::ApplyConditionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RemoveCondition(::grpc::ClientContext* context, const ::seshat::RemoveConditionRequest* request, ::seshat::RemoveConditionResponse* response, std::function<void(::grpc::Status)>) override;
      void RemoveCondition(::grpc::ClientContext* context, const ::seshat::RemoveConditionRequest* request, ::seshat::RemoveConditionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetConditions(::grpc::ClientContext* context, const ::seshat::GetConditionsRequest* request, ::seshat::GetConditionsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetConditions(::grpc::ClientContext* context, const ::seshat::GetConditionsRequest* request, ::seshat::GetConditionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateCondition(::grpc::ClientContext* context, const ::seshat::UpdateConditionRequest* request, ::seshat::UpdateConditionResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateCondition(::grpc::ClientContext* context, const ::seshat::UpdateConditionRequest* request, ::seshat::UpdateConditionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void HasCondition(::grpc::ClientContext* context, const ::seshat::HasConditionRequest* request, ::seshat::HasConditionResponse* response, std::function<void(::grpc::Status)>) override;
      void HasCondition(::grpc::ClientContext* context, const ::seshat::HasConditionRequest* request, ::seshat::HasConditionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetConditionsByType(::grpc::ClientContext* context, const ::seshat::GetConditionsByTypeRequest* request, ::seshat::GetConditionsByTypeResponse* response, std::function<void(::grpc::Status)>) override;
      void GetConditionsByType(::grpc::ClientContext* context, const ::seshat::GetConditionsByTypeRequest* request, ::seshat::GetConditionsByTypeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetActiveConditions(::grpc::ClientContext* context, const ::seshat::GetActiveConditionsRequest* request, ::seshat::GetActiveConditionsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetActiveConditions(::grpc::ClientContext* context, const ::seshat::GetActiveConditionsRequest* request, ::seshat::GetActiveConditionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CheckImmunity(::grpc::ClientContext* context, const ::seshat::CheckImmunityRequest* request, ::seshat::CheckImmunityResponse* response, std::function<void(::grpc::Status)>) override;
      void CheckImmunity(::grpc::ClientContext* context, const ::seshat::CheckImmunityRequest* request, ::seshat::CheckImmunityResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetConflictingConditions(::grpc::ClientContext* context, const ::seshat::GetConflictingConditionsRequest* request, ::seshat::GetConflictingConditionsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetConflictingConditions(::grpc::ClientContext* context, const ::seshat::GetConflictingConditionsRequest* request, ::seshat::GetConflictingConditionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ResolveConflicts(::grpc::ClientContext* context, const ::seshat::ResolveConflictsRequest* request, ::seshat::ResolveConflictsResponse* response, std::function<void(::grpc::Status)>) override;
      void ResolveConflicts(::grpc::ClientContext* context, const ::seshat::ResolveConflictsRequest* request, ::seshat::ResolveConflictsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetConditionTemplates(::grpc::ClientContext* context, const ::seshat::GetConditionTemplatesRequest* request, ::seshat::GetConditionTemplatesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetConditionTemplates(::grpc::ClientContext* context, const ::seshat::GetConditionTemplatesRequest* request, ::seshat::GetConditionTemplatesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreateConditionTemplate(::grpc::ClientContext* context, const ::seshat::CreateConditionTemplateRequest* request, ::seshat::CreateConditionTemplateResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateConditionTemplate(::grpc::ClientContext* context, const ::seshat::CreateConditionTemplateRequest* request, ::seshat::CreateConditionTemplateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ProcessConditionTick(::grpc::ClientContext* context, const ::seshat::ProcessConditionTickRequest* request, ::seshat::ProcessConditionTickResponse* response, std::function<void(::grpc::Status)>) override;
      void ProcessConditionTick(::grpc::ClientContext* context, const ::seshat::ProcessConditionTickRequest* request, ::seshat::ProcessConditionTickResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetConditionHistory(::grpc::ClientContext* context, const ::seshat::GetConditionHistoryRequest* request, ::seshat::GetConditionHistoryResponse* response, std::function<void(::grpc::Status)>) override;
      void GetConditionHistory(::grpc::ClientContext* context, const ::seshat::GetConditionHistoryRequest* request, ::seshat::GetConditionHistoryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::seshat::ApplyConditionResponse>* AsyncApplyConditionRaw(::grpc::ClientContext* context, const ::seshat::ApplyConditionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::ApplyConditionResponse>* PrepareAsyncApplyConditionRaw(::grpc::ClientContext* context, const ::seshat::ApplyConditionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::RemoveConditionResponse>* AsyncRemoveConditionRaw(::grpc::ClientContext* context, const ::seshat::RemoveConditionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::RemoveConditionResponse>* PrepareAsyncRemoveConditionRaw(::grpc::ClientContext* context, const ::seshat::RemoveConditionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionsResponse>* AsyncGetConditionsRaw(::grpc::ClientContext* context, const ::seshat::GetConditionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionsResponse>* PrepareAsyncGetConditionsRaw(::grpc::ClientContext* context, const ::seshat::GetConditionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::UpdateConditionResponse>* AsyncUpdateConditionRaw(::grpc::ClientContext* context, const ::seshat::UpdateConditionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::UpdateConditionResponse>* PrepareAsyncUpdateConditionRaw(::grpc::ClientContext* context, const ::seshat::UpdateConditionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::HasConditionResponse>* AsyncHasConditionRaw(::grpc::ClientContext* context, const ::seshat::HasConditionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::HasConditionResponse>* PrepareAsyncHasConditionRaw(::grpc::ClientContext* context, const ::seshat::HasConditionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionsByTypeResponse>* AsyncGetConditionsByTypeRaw(::grpc::ClientContext* context, const ::seshat::GetConditionsByTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionsByTypeResponse>* PrepareAsyncGetConditionsByTypeRaw(::grpc::ClientContext* context, const ::seshat::GetConditionsByTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetActiveConditionsResponse>* AsyncGetActiveConditionsRaw(::grpc::ClientContext* context, const ::seshat::GetActiveConditionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetActiveConditionsResponse>* PrepareAsyncGetActiveConditionsRaw(::grpc::ClientContext* context, const ::seshat::GetActiveConditionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::CheckImmunityResponse>* AsyncCheckImmunityRaw(::grpc::ClientContext* context, const ::seshat::CheckImmunityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::CheckImmunityResponse>* PrepareAsyncCheckImmunityRaw(::grpc::ClientContext* context, const ::seshat::CheckImmunityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetConflictingConditionsResponse>* AsyncGetConflictingConditionsRaw(::grpc::ClientContext* context, const ::seshat::GetConflictingConditionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetConflictingConditionsResponse>* PrepareAsyncGetConflictingConditionsRaw(::grpc::ClientContext* context, const ::seshat::GetConflictingConditionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::ResolveConflictsResponse>* AsyncResolveConflictsRaw(::grpc::ClientContext* context, const ::seshat::ResolveConflictsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::ResolveConflictsResponse>* PrepareAsyncResolveConflictsRaw(::grpc::ClientContext* context, const ::seshat::ResolveConflictsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionTemplatesResponse>* AsyncGetConditionTemplatesRaw(::grpc::ClientContext* context, const ::seshat::GetConditionTemplatesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionTemplatesResponse>* PrepareAsyncGetConditionTemplatesRaw(::grpc::ClientContext* context, const ::seshat::GetConditionTemplatesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::CreateConditionTemplateResponse>* AsyncCreateConditionTemplateRaw(::grpc::ClientContext* context, const ::seshat::CreateConditionTemplateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::CreateConditionTemplateResponse>* PrepareAsyncCreateConditionTemplateRaw(::grpc::ClientContext* context, const ::seshat::CreateConditionTemplateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::ProcessConditionTickResponse>* AsyncProcessConditionTickRaw(::grpc::ClientContext* context, const ::seshat::ProcessConditionTickRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::ProcessConditionTickResponse>* PrepareAsyncProcessConditionTickRaw(::grpc::ClientContext* context, const ::seshat::ProcessConditionTickRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionHistoryResponse>* AsyncGetConditionHistoryRaw(::grpc::ClientContext* context, const ::seshat::GetConditionHistoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetConditionHistoryResponse>* PrepareAsyncGetConditionHistoryRaw(::grpc::ClientContext* context, const ::seshat::GetConditionHistoryRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ApplyCondition_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveCondition_;
    const ::grpc::internal::RpcMethod rpcmethod_GetConditions_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateCondition_;
    const ::grpc::internal::RpcMethod rpcmethod_HasCondition_;
    const ::grpc::internal::RpcMethod rpcmethod_GetConditionsByType_;
    const ::grpc::internal::RpcMethod rpcmethod_GetActiveConditions_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckImmunity_;
    const ::grpc::internal::RpcMethod rpcmethod_GetConflictingConditions_;
    const ::grpc::internal::RpcMethod rpcmethod_ResolveConflicts_;
    const ::grpc::internal::RpcMethod rpcmethod_GetConditionTemplates_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateConditionTemplate_;
    const ::grpc::internal::RpcMethod rpcmethod_ProcessConditionTick_;
    const ::grpc::internal::RpcMethod rpcmethod_GetConditionHistory_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Condition management
    virtual ::grpc::Status ApplyCondition(::grpc::ServerContext* context, const ::seshat::ApplyConditionRequest* request, ::seshat::ApplyConditionResponse* response);
    virtual ::grpc::Status RemoveCondition(::grpc::ServerContext* context, const ::seshat::RemoveConditionRequest* request, ::seshat::RemoveConditionResponse* response);
    virtual ::grpc::Status GetConditions(::grpc::ServerContext* context, const ::seshat::GetConditionsRequest* request, ::seshat::GetConditionsResponse* response);
    virtual ::grpc::Status UpdateCondition(::grpc::ServerContext* context, const ::seshat::UpdateConditionRequest* request, ::seshat::UpdateConditionResponse* response);
    // Condition queries
    virtual ::grpc::Status HasCondition(::grpc::ServerContext* context, const ::seshat::HasConditionRequest* request, ::seshat::HasConditionResponse* response);
    virtual ::grpc::Status GetConditionsByType(::grpc::ServerContext* context, const ::seshat::GetConditionsByTypeRequest* request, ::seshat::GetConditionsByTypeResponse* response);
    virtual ::grpc::Status GetActiveConditions(::grpc::ServerContext* context, const ::seshat::GetActiveConditionsRequest* request, ::seshat::GetActiveConditionsResponse* response);
    // Condition relationships
    virtual ::grpc::Status CheckImmunity(::grpc::ServerContext* context, const ::seshat::CheckImmunityRequest* request, ::seshat::CheckImmunityResponse* response);
    virtual ::grpc::Status GetConflictingConditions(::grpc::ServerContext* context, const ::seshat::GetConflictingConditionsRequest* request, ::seshat::GetConflictingConditionsResponse* response);
    virtual ::grpc::Status ResolveConflicts(::grpc::ServerContext* context, const ::seshat::ResolveConflictsRequest* request, ::seshat::ResolveConflictsResponse* response);
    // Condition templates
    virtual ::grpc::Status GetConditionTemplates(::grpc::ServerContext* context, const ::seshat::GetConditionTemplatesRequest* request, ::seshat::GetConditionTemplatesResponse* response);
    virtual ::grpc::Status CreateConditionTemplate(::grpc::ServerContext* context, const ::seshat::CreateConditionTemplateRequest* request, ::seshat::CreateConditionTemplateResponse* response);
    // Advanced features
    virtual ::grpc::Status ProcessConditionTick(::grpc::ServerContext* context, const ::seshat::ProcessConditionTickRequest* request, ::seshat::ProcessConditionTickResponse* response);
    virtual ::grpc::Status GetConditionHistory(::grpc::ServerContext* context, const ::seshat::GetConditionHistoryRequest* request, ::seshat::GetConditionHistoryResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ApplyCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ApplyCondition() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ApplyCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ApplyCondition(::grpc::ServerContext* /*context*/, const ::seshat::ApplyConditionRequest* /*request*/, ::seshat::ApplyConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestApplyCondition(::grpc::ServerContext* context, ::seshat::ApplyConditionRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::ApplyConditionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemoveCondition() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_RemoveCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveCondition(::grpc::ServerContext* /*context*/, const ::seshat::RemoveConditionRequest* /*request*/, ::seshat::RemoveConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveCondition(::grpc::ServerContext* context, ::seshat::RemoveConditionRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::RemoveConditionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetConditions() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionsRequest* /*request*/, ::seshat::GetConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConditions(::grpc::ServerContext* context, ::seshat::GetConditionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GetConditionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateCondition() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_UpdateCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateCondition(::grpc::ServerContext* /*context*/, const ::seshat::UpdateConditionRequest* /*request*/, ::seshat::UpdateConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateCondition(::grpc::ServerContext* context, ::seshat::UpdateConditionRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::UpdateConditionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HasCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HasCondition() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_HasCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HasCondition(::grpc::ServerContext* /*context*/, const ::seshat::HasConditionRequest* /*request*/, ::seshat::HasConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHasCondition(::grpc::ServerContext* context, ::seshat::HasConditionRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::HasConditionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetConditionsByType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetConditionsByType() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetConditionsByType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditionsByType(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionsByTypeRequest* /*request*/, ::seshat::GetConditionsByTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConditionsByType(::grpc::ServerContext* context, ::seshat::GetConditionsByTypeRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GetConditionsByTypeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetActiveConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetActiveConditions() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetActiveConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetActiveConditionsRequest* /*request*/, ::seshat::GetActiveConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActiveConditions(::grpc::ServerContext* context, ::seshat::GetActiveConditionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GetActiveConditionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckImmunity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckImmunity() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_CheckImmunity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckImmunity(::grpc::ServerContext* /*context*/, const ::seshat::CheckImmunityRequest* /*request*/, ::seshat::CheckImmunityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckImmunity(::grpc::ServerContext* context, ::seshat::CheckImmunityRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::CheckImmunityResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetConflictingConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetConflictingConditions() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_GetConflictingConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConflictingConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetConflictingConditionsRequest* /*request*/, ::seshat::GetConflictingConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConflictingConditions(::grpc::ServerContext* context, ::seshat::GetConflictingConditionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GetConflictingConditionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResolveConflicts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResolveConflicts() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_ResolveConflicts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResolveConflicts(::grpc::ServerContext* /*context*/, const ::seshat::ResolveConflictsRequest* /*request*/, ::seshat::ResolveConflictsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResolveConflicts(::grpc::ServerContext* context, ::seshat::ResolveConflictsRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::ResolveConflictsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetConditionTemplates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetConditionTemplates() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetConditionTemplates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditionTemplates(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionTemplatesRequest* /*request*/, ::seshat::GetConditionTemplatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConditionTemplates(::grpc::ServerContext* context, ::seshat::GetConditionTemplatesRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GetConditionTemplatesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateConditionTemplate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateConditionTemplate() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_CreateConditionTemplate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateConditionTemplate(::grpc::ServerContext* /*context*/, const ::seshat::CreateConditionTemplateRequest* /*request*/, ::seshat::CreateConditionTemplateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateConditionTemplate(::grpc::ServerContext* context, ::seshat::CreateConditionTemplateRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::CreateConditionTemplateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ProcessConditionTick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ProcessConditionTick() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_ProcessConditionTick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessConditionTick(::grpc::ServerContext* /*context*/, const ::seshat::ProcessConditionTickRequest* /*request*/, ::seshat::ProcessConditionTickResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProcessConditionTick(::grpc::ServerContext* context, ::seshat::ProcessConditionTickRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::ProcessConditionTickResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetConditionHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetConditionHistory() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_GetConditionHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditionHistory(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionHistoryRequest* /*request*/, ::seshat::GetConditionHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConditionHistory(::grpc::ServerContext* context, ::seshat::GetConditionHistoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GetConditionHistoryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ApplyCondition<WithAsyncMethod_RemoveCondition<WithAsyncMethod_GetConditions<WithAsyncMethod_UpdateCondition<WithAsyncMethod_HasCondition<WithAsyncMethod_GetConditionsByType<WithAsyncMethod_GetActiveConditions<WithAsyncMethod_CheckImmunity<WithAsyncMethod_GetConflictingConditions<WithAsyncMethod_ResolveConflicts<WithAsyncMethod_GetConditionTemplates<WithAsyncMethod_CreateConditionTemplate<WithAsyncMethod_ProcessConditionTick<WithAsyncMethod_GetConditionHistory<Service > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_ApplyCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ApplyCondition() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::ApplyConditionRequest, ::seshat::ApplyConditionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::ApplyConditionRequest* request, ::seshat::ApplyConditionResponse* response) { return this->ApplyCondition(context, request, response); }));}
    void SetMessageAllocatorFor_ApplyCondition(
        ::grpc::MessageAllocator< ::seshat::ApplyConditionRequest, ::seshat::ApplyConditionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::ApplyConditionRequest, ::seshat::ApplyConditionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ApplyCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ApplyCondition(::grpc::ServerContext* /*context*/, const ::seshat::ApplyConditionRequest* /*request*/, ::seshat::ApplyConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ApplyCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::ApplyConditionRequest* /*request*/, ::seshat::ApplyConditionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RemoveCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RemoveCondition() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::RemoveConditionRequest, ::seshat::RemoveConditionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::RemoveConditionRequest* request, ::seshat::RemoveConditionResponse* response) { return this->RemoveCondition(context, request, response); }));}
    void SetMessageAllocatorFor_RemoveCondition(
        ::grpc::MessageAllocator< ::seshat::RemoveConditionRequest, ::seshat::RemoveConditionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::RemoveConditionRequest, ::seshat::RemoveConditionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RemoveCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveCondition(::grpc::ServerContext* /*context*/, const ::seshat::RemoveConditionRequest* /*request*/, ::seshat::RemoveConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemoveCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::RemoveConditionRequest* /*request*/, ::seshat::RemoveConditionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetConditions() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GetConditionsRequest, ::seshat::GetConditionsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GetConditionsRequest* request, ::seshat::GetConditionsResponse* response) { return this->GetConditions(context, request, response); }));}
    void SetMessageAllocatorFor_GetConditions(
        ::grpc::MessageAllocator< ::seshat::GetConditionsRequest, ::seshat::GetConditionsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GetConditionsRequest, ::seshat::GetConditionsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionsRequest* /*request*/, ::seshat::GetConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConditions(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GetConditionsRequest* /*request*/, ::seshat::GetConditionsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateCondition() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::UpdateConditionRequest, ::seshat::UpdateConditionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::UpdateConditionRequest* request, ::seshat::UpdateConditionResponse* response) { return this->UpdateCondition(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateCondition(
        ::grpc::MessageAllocator< ::seshat::UpdateConditionRequest, ::seshat::UpdateConditionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::UpdateConditionRequest, ::seshat::UpdateConditionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateCondition(::grpc::ServerContext* /*context*/, const ::seshat::UpdateConditionRequest* /*request*/, ::seshat::UpdateConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::UpdateConditionRequest* /*request*/, ::seshat::UpdateConditionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_HasCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_HasCondition() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::HasConditionRequest, ::seshat::HasConditionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::HasConditionRequest* request, ::seshat::HasConditionResponse* response) { return this->HasCondition(context, request, response); }));}
    void SetMessageAllocatorFor_HasCondition(
        ::grpc::MessageAllocator< ::seshat::HasConditionRequest, ::seshat::HasConditionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::HasConditionRequest, ::seshat::HasConditionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_HasCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HasCondition(::grpc::ServerContext* /*context*/, const ::seshat::HasConditionRequest* /*request*/, ::seshat::HasConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HasCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::HasConditionRequest* /*request*/, ::seshat::HasConditionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetConditionsByType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetConditionsByType() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GetConditionsByTypeRequest, ::seshat::GetConditionsByTypeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GetConditionsByTypeRequest* request, ::seshat::GetConditionsByTypeResponse* response) { return this->GetConditionsByType(context, request, response); }));}
    void SetMessageAllocatorFor_GetConditionsByType(
        ::grpc::MessageAllocator< ::seshat::GetConditionsByTypeRequest, ::seshat::GetConditionsByTypeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GetConditionsByTypeRequest, ::seshat::GetConditionsByTypeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetConditionsByType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditionsByType(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionsByTypeRequest* /*request*/, ::seshat::GetConditionsByTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConditionsByType(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GetConditionsByTypeRequest* /*request*/, ::seshat::GetConditionsByTypeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetActiveConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetActiveConditions() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GetActiveConditionsRequest, ::seshat::GetActiveConditionsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GetActiveConditionsRequest* request, ::seshat::GetActiveConditionsResponse* response) { return this->GetActiveConditions(context, request, response); }));}
    void SetMessageAllocatorFor_GetActiveConditions(
        ::grpc::MessageAllocator< ::seshat::GetActiveConditionsRequest, ::seshat::GetActiveConditionsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GetActiveConditionsRequest, ::seshat::GetActiveConditionsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetActiveConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetActiveConditionsRequest* /*request*/, ::seshat::GetActiveConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetActiveConditions(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GetActiveConditionsRequest* /*request*/, ::seshat::GetActiveConditionsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CheckImmunity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CheckImmunity() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::CheckImmunityRequest, ::seshat::CheckImmunityResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::CheckImmunityRequest* request, ::seshat::CheckImmunityResponse* response) { return this->CheckImmunity(context, request, response); }));}
    void SetMessageAllocatorFor_CheckImmunity(
        ::grpc::MessageAllocator< ::seshat::CheckImmunityRequest, ::seshat::CheckImmunityResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::CheckImmunityRequest, ::seshat::CheckImmunityResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CheckImmunity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckImmunity(::grpc::ServerContext* /*context*/, const ::seshat::CheckImmunityRequest* /*request*/, ::seshat::CheckImmunityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckImmunity(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::CheckImmunityRequest* /*request*/, ::seshat::CheckImmunityResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetConflictingConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetConflictingConditions() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GetConflictingConditionsRequest, ::seshat::GetConflictingConditionsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GetConflictingConditionsRequest* request, ::seshat::GetConflictingConditionsResponse* response) { return this->GetConflictingConditions(context, request, response); }));}
    void SetMessageAllocatorFor_GetConflictingConditions(
        ::grpc::MessageAllocator< ::seshat::GetConflictingConditionsRequest, ::seshat::GetConflictingConditionsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GetConflictingConditionsRequest, ::seshat::GetConflictingConditionsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetConflictingConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConflictingConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetConflictingConditionsRequest* /*request*/, ::seshat::GetConflictingConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConflictingConditions(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GetConflictingConditionsRequest* /*request*/, ::seshat::GetConflictingConditionsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ResolveConflicts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ResolveConflicts() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::ResolveConflictsRequest, ::seshat::ResolveConflictsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::ResolveConflictsRequest* request, ::seshat::ResolveConflictsResponse* response) { return this->ResolveConflicts(context, request, response); }));}
    void SetMessageAllocatorFor_ResolveConflicts(
        ::grpc::MessageAllocator< ::seshat::ResolveConflictsRequest, ::seshat::ResolveConflictsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::ResolveConflictsRequest, ::seshat::ResolveConflictsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ResolveConflicts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResolveConflicts(::grpc::ServerContext* /*context*/, const ::seshat::ResolveConflictsRequest* /*request*/, ::seshat::ResolveConflictsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResolveConflicts(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::ResolveConflictsRequest* /*request*/, ::seshat::ResolveConflictsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetConditionTemplates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetConditionTemplates() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GetConditionTemplatesRequest, ::seshat::GetConditionTemplatesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GetConditionTemplatesRequest* request, ::seshat::GetConditionTemplatesResponse* response) { return this->GetConditionTemplates(context, request, response); }));}
    void SetMessageAllocatorFor_GetConditionTemplates(
        ::grpc::MessageAllocator< ::seshat::GetConditionTemplatesRequest, ::seshat::GetConditionTemplatesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GetConditionTemplatesRequest, ::seshat::GetConditionTemplatesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetConditionTemplates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditionTemplates(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionTemplatesRequest* /*request*/, ::seshat::GetConditionTemplatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConditionTemplates(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GetConditionTemplatesRequest* /*request*/, ::seshat::GetConditionTemplatesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateConditionTemplate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateConditionTemplate() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::CreateConditionTemplateRequest, ::seshat::CreateConditionTemplateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::CreateConditionTemplateRequest* request, ::seshat::CreateConditionTemplateResponse* response) { return this->CreateConditionTemplate(context, request, response); }));}
    void SetMessageAllocatorFor_CreateConditionTemplate(
        ::grpc::MessageAllocator< ::seshat::CreateConditionTemplateRequest, ::seshat::CreateConditionTemplateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::CreateConditionTemplateRequest, ::seshat::CreateConditionTemplateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateConditionTemplate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateConditionTemplate(::grpc::ServerContext* /*context*/, const ::seshat::CreateConditionTemplateRequest* /*request*/, ::seshat::CreateConditionTemplateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateConditionTemplate(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::CreateConditionTemplateRequest* /*request*/, ::seshat::CreateConditionTemplateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ProcessConditionTick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ProcessConditionTick() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::ProcessConditionTickRequest, ::seshat::ProcessConditionTickResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::ProcessConditionTickRequest* request, ::seshat::ProcessConditionTickResponse* response) { return this->ProcessConditionTick(context, request, response); }));}
    void SetMessageAllocatorFor_ProcessConditionTick(
        ::grpc::MessageAllocator< ::seshat::ProcessConditionTickRequest, ::seshat::ProcessConditionTickResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::ProcessConditionTickRequest, ::seshat::ProcessConditionTickResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ProcessConditionTick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessConditionTick(::grpc::ServerContext* /*context*/, const ::seshat::ProcessConditionTickRequest* /*request*/, ::seshat::ProcessConditionTickResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ProcessConditionTick(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::ProcessConditionTickRequest* /*request*/, ::seshat::ProcessConditionTickResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetConditionHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetConditionHistory() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GetConditionHistoryRequest, ::seshat::GetConditionHistoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GetConditionHistoryRequest* request, ::seshat::GetConditionHistoryResponse* response) { return this->GetConditionHistory(context, request, response); }));}
    void SetMessageAllocatorFor_GetConditionHistory(
        ::grpc::MessageAllocator< ::seshat::GetConditionHistoryRequest, ::seshat::GetConditionHistoryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GetConditionHistoryRequest, ::seshat::GetConditionHistoryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetConditionHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditionHistory(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionHistoryRequest* /*request*/, ::seshat::GetConditionHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConditionHistory(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GetConditionHistoryRequest* /*request*/, ::seshat::GetConditionHistoryResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_ApplyCondition<WithCallbackMethod_RemoveCondition<WithCallbackMethod_GetConditions<WithCallbackMethod_UpdateCondition<WithCallbackMethod_HasCondition<WithCallbackMethod_GetConditionsByType<WithCallbackMethod_GetActiveConditions<WithCallbackMethod_CheckImmunity<WithCallbackMethod_GetConflictingConditions<WithCallbackMethod_ResolveConflicts<WithCallbackMethod_GetConditionTemplates<WithCallbackMethod_CreateConditionTemplate<WithCallbackMethod_ProcessConditionTick<WithCallbackMethod_GetConditionHistory<Service > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ApplyCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ApplyCondition() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ApplyCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ApplyCondition(::grpc::ServerContext* /*context*/, const ::seshat::ApplyConditionRequest* /*request*/, ::seshat::ApplyConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemoveCondition() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_RemoveCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveCondition(::grpc::ServerContext* /*context*/, const ::seshat::RemoveConditionRequest* /*request*/, ::seshat::RemoveConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetConditions() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionsRequest* /*request*/, ::seshat::GetConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateCondition() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_UpdateCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateCondition(::grpc::ServerContext* /*context*/, const ::seshat::UpdateConditionRequest* /*request*/, ::seshat::UpdateConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HasCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HasCondition() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_HasCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HasCondition(::grpc::ServerContext* /*context*/, const ::seshat::HasConditionRequest* /*request*/, ::seshat::HasConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetConditionsByType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetConditionsByType() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetConditionsByType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditionsByType(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionsByTypeRequest* /*request*/, ::seshat::GetConditionsByTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetActiveConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetActiveConditions() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetActiveConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetActiveConditionsRequest* /*request*/, ::seshat::GetActiveConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckImmunity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckImmunity() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_CheckImmunity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckImmunity(::grpc::ServerContext* /*context*/, const ::seshat::CheckImmunityRequest* /*request*/, ::seshat::CheckImmunityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetConflictingConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetConflictingConditions() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_GetConflictingConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConflictingConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetConflictingConditionsRequest* /*request*/, ::seshat::GetConflictingConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResolveConflicts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResolveConflicts() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_ResolveConflicts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResolveConflicts(::grpc::ServerContext* /*context*/, const ::seshat::ResolveConflictsRequest* /*request*/, ::seshat::ResolveConflictsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetConditionTemplates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetConditionTemplates() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetConditionTemplates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditionTemplates(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionTemplatesRequest* /*request*/, ::seshat::GetConditionTemplatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateConditionTemplate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateConditionTemplate() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_CreateConditionTemplate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateConditionTemplate(::grpc::ServerContext* /*context*/, const ::seshat::CreateConditionTemplateRequest* /*request*/, ::seshat::CreateConditionTemplateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ProcessConditionTick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ProcessConditionTick() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_ProcessConditionTick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessConditionTick(::grpc::ServerContext* /*context*/, const ::seshat::ProcessConditionTickRequest* /*request*/, ::seshat::ProcessConditionTickResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetConditionHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetConditionHistory() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_GetConditionHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditionHistory(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionHistoryRequest* /*request*/, ::seshat::GetConditionHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ApplyCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ApplyCondition() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ApplyCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ApplyCondition(::grpc::ServerContext* /*context*/, const ::seshat::ApplyConditionRequest* /*request*/, ::seshat::ApplyConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestApplyCondition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoveCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemoveCondition() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_RemoveCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveCondition(::grpc::ServerContext* /*context*/, const ::seshat::RemoveConditionRequest* /*request*/, ::seshat::RemoveConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveCondition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetConditions() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionsRequest* /*request*/, ::seshat::GetConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConditions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateCondition() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_UpdateCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateCondition(::grpc::ServerContext* /*context*/, const ::seshat::UpdateConditionRequest* /*request*/, ::seshat::UpdateConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateCondition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HasCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HasCondition() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_HasCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HasCondition(::grpc::ServerContext* /*context*/, const ::seshat::HasConditionRequest* /*request*/, ::seshat::HasConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHasCondition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetConditionsByType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetConditionsByType() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetConditionsByType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditionsByType(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionsByTypeRequest* /*request*/, ::seshat::GetConditionsByTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConditionsByType(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetActiveConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetActiveConditions() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetActiveConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetActiveConditionsRequest* /*request*/, ::seshat::GetActiveConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActiveConditions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckImmunity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckImmunity() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_CheckImmunity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckImmunity(::grpc::ServerContext* /*context*/, const ::seshat::CheckImmunityRequest* /*request*/, ::seshat::CheckImmunityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckImmunity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetConflictingConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetConflictingConditions() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_GetConflictingConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConflictingConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetConflictingConditionsRequest* /*request*/, ::seshat::GetConflictingConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConflictingConditions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResolveConflicts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResolveConflicts() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_ResolveConflicts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResolveConflicts(::grpc::ServerContext* /*context*/, const ::seshat::ResolveConflictsRequest* /*request*/, ::seshat::ResolveConflictsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResolveConflicts(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetConditionTemplates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetConditionTemplates() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetConditionTemplates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditionTemplates(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionTemplatesRequest* /*request*/, ::seshat::GetConditionTemplatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConditionTemplates(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateConditionTemplate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateConditionTemplate() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_CreateConditionTemplate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateConditionTemplate(::grpc::ServerContext* /*context*/, const ::seshat::CreateConditionTemplateRequest* /*request*/, ::seshat::CreateConditionTemplateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateConditionTemplate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ProcessConditionTick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ProcessConditionTick() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_ProcessConditionTick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessConditionTick(::grpc::ServerContext* /*context*/, const ::seshat::ProcessConditionTickRequest* /*request*/, ::seshat::ProcessConditionTickResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProcessConditionTick(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetConditionHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetConditionHistory() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_GetConditionHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditionHistory(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionHistoryRequest* /*request*/, ::seshat::GetConditionHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetConditionHistory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ApplyCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ApplyCondition() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ApplyCondition(context, request, response); }));
    }
    ~WithRawCallbackMethod_ApplyCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ApplyCondition(::grpc::ServerContext* /*context*/, const ::seshat::ApplyConditionRequest* /*request*/, ::seshat::ApplyConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ApplyCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RemoveCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RemoveCondition() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemoveCondition(context, request, response); }));
    }
    ~WithRawCallbackMethod_RemoveCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveCondition(::grpc::ServerContext* /*context*/, const ::seshat::RemoveConditionRequest* /*request*/, ::seshat::RemoveConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemoveCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetConditions() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetConditions(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionsRequest* /*request*/, ::seshat::GetConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConditions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateCondition() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateCondition(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateCondition(::grpc::ServerContext* /*context*/, const ::seshat::UpdateConditionRequest* /*request*/, ::seshat::UpdateConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_HasCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_HasCondition() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HasCondition(context, request, response); }));
    }
    ~WithRawCallbackMethod_HasCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HasCondition(::grpc::ServerContext* /*context*/, const ::seshat::HasConditionRequest* /*request*/, ::seshat::HasConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HasCondition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetConditionsByType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetConditionsByType() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetConditionsByType(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetConditionsByType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditionsByType(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionsByTypeRequest* /*request*/, ::seshat::GetConditionsByTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConditionsByType(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetActiveConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetActiveConditions() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetActiveConditions(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetActiveConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetActiveConditionsRequest* /*request*/, ::seshat::GetActiveConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetActiveConditions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CheckImmunity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CheckImmunity() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckImmunity(context, request, response); }));
    }
    ~WithRawCallbackMethod_CheckImmunity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckImmunity(::grpc::ServerContext* /*context*/, const ::seshat::CheckImmunityRequest* /*request*/, ::seshat::CheckImmunityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckImmunity(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetConflictingConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetConflictingConditions() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetConflictingConditions(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetConflictingConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConflictingConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetConflictingConditionsRequest* /*request*/, ::seshat::GetConflictingConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConflictingConditions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ResolveConflicts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ResolveConflicts() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResolveConflicts(context, request, response); }));
    }
    ~WithRawCallbackMethod_ResolveConflicts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResolveConflicts(::grpc::ServerContext* /*context*/, const ::seshat::ResolveConflictsRequest* /*request*/, ::seshat::ResolveConflictsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ResolveConflicts(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetConditionTemplates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetConditionTemplates() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetConditionTemplates(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetConditionTemplates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditionTemplates(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionTemplatesRequest* /*request*/, ::seshat::GetConditionTemplatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConditionTemplates(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateConditionTemplate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateConditionTemplate() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateConditionTemplate(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateConditionTemplate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateConditionTemplate(::grpc::ServerContext* /*context*/, const ::seshat::CreateConditionTemplateRequest* /*request*/, ::seshat::CreateConditionTemplateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateConditionTemplate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ProcessConditionTick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ProcessConditionTick() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ProcessConditionTick(context, request, response); }));
    }
    ~WithRawCallbackMethod_ProcessConditionTick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ProcessConditionTick(::grpc::ServerContext* /*context*/, const ::seshat::ProcessConditionTickRequest* /*request*/, ::seshat::ProcessConditionTickResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ProcessConditionTick(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetConditionHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetConditionHistory() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetConditionHistory(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetConditionHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetConditionHistory(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionHistoryRequest* /*request*/, ::seshat::GetConditionHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetConditionHistory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ApplyCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ApplyCondition() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::ApplyConditionRequest, ::seshat::ApplyConditionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::ApplyConditionRequest, ::seshat::ApplyConditionResponse>* streamer) {
                       return this->StreamedApplyCondition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ApplyCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ApplyCondition(::grpc::ServerContext* /*context*/, const ::seshat::ApplyConditionRequest* /*request*/, ::seshat::ApplyConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedApplyCondition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::ApplyConditionRequest,::seshat::ApplyConditionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemoveCondition() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::RemoveConditionRequest, ::seshat::RemoveConditionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::RemoveConditionRequest, ::seshat::RemoveConditionResponse>* streamer) {
                       return this->StreamedRemoveCondition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemoveCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveCondition(::grpc::ServerContext* /*context*/, const ::seshat::RemoveConditionRequest* /*request*/, ::seshat::RemoveConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveCondition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::RemoveConditionRequest,::seshat::RemoveConditionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetConditions() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GetConditionsRequest, ::seshat::GetConditionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GetConditionsRequest, ::seshat::GetConditionsResponse>* streamer) {
                       return this->StreamedGetConditions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionsRequest* /*request*/, ::seshat::GetConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetConditions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GetConditionsRequest,::seshat::GetConditionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateCondition() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::UpdateConditionRequest, ::seshat::UpdateConditionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::UpdateConditionRequest, ::seshat::UpdateConditionResponse>* streamer) {
                       return this->StreamedUpdateCondition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateCondition(::grpc::ServerContext* /*context*/, const ::seshat::UpdateConditionRequest* /*request*/, ::seshat::UpdateConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateCondition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::UpdateConditionRequest,::seshat::UpdateConditionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HasCondition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HasCondition() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::HasConditionRequest, ::seshat::HasConditionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::HasConditionRequest, ::seshat::HasConditionResponse>* streamer) {
                       return this->StreamedHasCondition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HasCondition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HasCondition(::grpc::ServerContext* /*context*/, const ::seshat::HasConditionRequest* /*request*/, ::seshat::HasConditionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHasCondition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::HasConditionRequest,::seshat::HasConditionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetConditionsByType : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetConditionsByType() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GetConditionsByTypeRequest, ::seshat::GetConditionsByTypeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GetConditionsByTypeRequest, ::seshat::GetConditionsByTypeResponse>* streamer) {
                       return this->StreamedGetConditionsByType(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetConditionsByType() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetConditionsByType(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionsByTypeRequest* /*request*/, ::seshat::GetConditionsByTypeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetConditionsByType(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GetConditionsByTypeRequest,::seshat::GetConditionsByTypeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetActiveConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetActiveConditions() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GetActiveConditionsRequest, ::seshat::GetActiveConditionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GetActiveConditionsRequest, ::seshat::GetActiveConditionsResponse>* streamer) {
                       return this->StreamedGetActiveConditions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetActiveConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetActiveConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetActiveConditionsRequest* /*request*/, ::seshat::GetActiveConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetActiveConditions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GetActiveConditionsRequest,::seshat::GetActiveConditionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckImmunity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckImmunity() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::CheckImmunityRequest, ::seshat::CheckImmunityResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::CheckImmunityRequest, ::seshat::CheckImmunityResponse>* streamer) {
                       return this->StreamedCheckImmunity(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckImmunity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckImmunity(::grpc::ServerContext* /*context*/, const ::seshat::CheckImmunityRequest* /*request*/, ::seshat::CheckImmunityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckImmunity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::CheckImmunityRequest,::seshat::CheckImmunityResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetConflictingConditions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetConflictingConditions() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GetConflictingConditionsRequest, ::seshat::GetConflictingConditionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GetConflictingConditionsRequest, ::seshat::GetConflictingConditionsResponse>* streamer) {
                       return this->StreamedGetConflictingConditions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetConflictingConditions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetConflictingConditions(::grpc::ServerContext* /*context*/, const ::seshat::GetConflictingConditionsRequest* /*request*/, ::seshat::GetConflictingConditionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetConflictingConditions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GetConflictingConditionsRequest,::seshat::GetConflictingConditionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResolveConflicts : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResolveConflicts() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::ResolveConflictsRequest, ::seshat::ResolveConflictsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::ResolveConflictsRequest, ::seshat::ResolveConflictsResponse>* streamer) {
                       return this->StreamedResolveConflicts(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResolveConflicts() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResolveConflicts(::grpc::ServerContext* /*context*/, const ::seshat::ResolveConflictsRequest* /*request*/, ::seshat::ResolveConflictsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResolveConflicts(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::ResolveConflictsRequest,::seshat::ResolveConflictsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetConditionTemplates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetConditionTemplates() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GetConditionTemplatesRequest, ::seshat::GetConditionTemplatesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GetConditionTemplatesRequest, ::seshat::GetConditionTemplatesResponse>* streamer) {
                       return this->StreamedGetConditionTemplates(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetConditionTemplates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetConditionTemplates(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionTemplatesRequest* /*request*/, ::seshat::GetConditionTemplatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetConditionTemplates(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GetConditionTemplatesRequest,::seshat::GetConditionTemplatesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateConditionTemplate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateConditionTemplate() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::CreateConditionTemplateRequest, ::seshat::CreateConditionTemplateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::CreateConditionTemplateRequest, ::seshat::CreateConditionTemplateResponse>* streamer) {
                       return this->StreamedCreateConditionTemplate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateConditionTemplate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateConditionTemplate(::grpc::ServerContext* /*context*/, const ::seshat::CreateConditionTemplateRequest* /*request*/, ::seshat::CreateConditionTemplateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateConditionTemplate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::CreateConditionTemplateRequest,::seshat::CreateConditionTemplateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ProcessConditionTick : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ProcessConditionTick() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::ProcessConditionTickRequest, ::seshat::ProcessConditionTickResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::ProcessConditionTickRequest, ::seshat::ProcessConditionTickResponse>* streamer) {
                       return this->StreamedProcessConditionTick(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ProcessConditionTick() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ProcessConditionTick(::grpc::ServerContext* /*context*/, const ::seshat::ProcessConditionTickRequest* /*request*/, ::seshat::ProcessConditionTickResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedProcessConditionTick(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::ProcessConditionTickRequest,::seshat::ProcessConditionTickResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetConditionHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetConditionHistory() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GetConditionHistoryRequest, ::seshat::GetConditionHistoryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GetConditionHistoryRequest, ::seshat::GetConditionHistoryResponse>* streamer) {
                       return this->StreamedGetConditionHistory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetConditionHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetConditionHistory(::grpc::ServerContext* /*context*/, const ::seshat::GetConditionHistoryRequest* /*request*/, ::seshat::GetConditionHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetConditionHistory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GetConditionHistoryRequest,::seshat::GetConditionHistoryResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ApplyCondition<WithStreamedUnaryMethod_RemoveCondition<WithStreamedUnaryMethod_GetConditions<WithStreamedUnaryMethod_UpdateCondition<WithStreamedUnaryMethod_HasCondition<WithStreamedUnaryMethod_GetConditionsByType<WithStreamedUnaryMethod_GetActiveConditions<WithStreamedUnaryMethod_CheckImmunity<WithStreamedUnaryMethod_GetConflictingConditions<WithStreamedUnaryMethod_ResolveConflicts<WithStreamedUnaryMethod_GetConditionTemplates<WithStreamedUnaryMethod_CreateConditionTemplate<WithStreamedUnaryMethod_ProcessConditionTick<WithStreamedUnaryMethod_GetConditionHistory<Service > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ApplyCondition<WithStreamedUnaryMethod_RemoveCondition<WithStreamedUnaryMethod_GetConditions<WithStreamedUnaryMethod_UpdateCondition<WithStreamedUnaryMethod_HasCondition<WithStreamedUnaryMethod_GetConditionsByType<WithStreamedUnaryMethod_GetActiveConditions<WithStreamedUnaryMethod_CheckImmunity<WithStreamedUnaryMethod_GetConflictingConditions<WithStreamedUnaryMethod_ResolveConflicts<WithStreamedUnaryMethod_GetConditionTemplates<WithStreamedUnaryMethod_CreateConditionTemplate<WithStreamedUnaryMethod_ProcessConditionTick<WithStreamedUnaryMethod_GetConditionHistory<Service > > > > > > > > > > > > > > StreamedService;
};

}  // namespace seshat


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_seshat_2fconditions_2eproto__INCLUDED
