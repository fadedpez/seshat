// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: seshat/spawn.proto
#ifndef GRPC_seshat_2fspawn_2eproto__INCLUDED
#define GRPC_seshat_2fspawn_2eproto__INCLUDED

#include "seshat/spawn.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace seshat {

// Spawn system service - exposes all spawn toolkit functionality
class SpawnService final {
 public:
  static constexpr char const* service_full_name() {
    return "seshat.SpawnService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Spawn engine management
    virtual ::grpc::Status CreateSpawnEngine(::grpc::ClientContext* context, const ::seshat::CreateSpawnEngineRequest& request, ::seshat::CreateSpawnEngineResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateSpawnEngineResponse>> AsyncCreateSpawnEngine(::grpc::ClientContext* context, const ::seshat::CreateSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateSpawnEngineResponse>>(AsyncCreateSpawnEngineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateSpawnEngineResponse>> PrepareAsyncCreateSpawnEngine(::grpc::ClientContext* context, const ::seshat::CreateSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateSpawnEngineResponse>>(PrepareAsyncCreateSpawnEngineRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSpawnEngine(::grpc::ClientContext* context, const ::seshat::GetSpawnEngineRequest& request, ::seshat::GetSpawnEngineResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnEngineResponse>> AsyncGetSpawnEngine(::grpc::ClientContext* context, const ::seshat::GetSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnEngineResponse>>(AsyncGetSpawnEngineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnEngineResponse>> PrepareAsyncGetSpawnEngine(::grpc::ClientContext* context, const ::seshat::GetSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnEngineResponse>>(PrepareAsyncGetSpawnEngineRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteSpawnEngine(::grpc::ClientContext* context, const ::seshat::DeleteSpawnEngineRequest& request, ::seshat::DeleteSpawnEngineResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DeleteSpawnEngineResponse>> AsyncDeleteSpawnEngine(::grpc::ClientContext* context, const ::seshat::DeleteSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DeleteSpawnEngineResponse>>(AsyncDeleteSpawnEngineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DeleteSpawnEngineResponse>> PrepareAsyncDeleteSpawnEngine(::grpc::ClientContext* context, const ::seshat::DeleteSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DeleteSpawnEngineResponse>>(PrepareAsyncDeleteSpawnEngineRaw(context, request, cq));
    }
    // Entity spawning
    virtual ::grpc::Status SpawnEntity(::grpc::ClientContext* context, const ::seshat::SpawnEntityRequest& request, ::seshat::SpawnEntityResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnEntityResponse>> AsyncSpawnEntity(::grpc::ClientContext* context, const ::seshat::SpawnEntityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnEntityResponse>>(AsyncSpawnEntityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnEntityResponse>> PrepareAsyncSpawnEntity(::grpc::ClientContext* context, const ::seshat::SpawnEntityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnEntityResponse>>(PrepareAsyncSpawnEntityRaw(context, request, cq));
    }
    virtual ::grpc::Status SpawnMultipleEntities(::grpc::ClientContext* context, const ::seshat::SpawnMultipleEntitiesRequest& request, ::seshat::SpawnMultipleEntitiesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnMultipleEntitiesResponse>> AsyncSpawnMultipleEntities(::grpc::ClientContext* context, const ::seshat::SpawnMultipleEntitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnMultipleEntitiesResponse>>(AsyncSpawnMultipleEntitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnMultipleEntitiesResponse>> PrepareAsyncSpawnMultipleEntities(::grpc::ClientContext* context, const ::seshat::SpawnMultipleEntitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnMultipleEntitiesResponse>>(PrepareAsyncSpawnMultipleEntitiesRaw(context, request, cq));
    }
    virtual ::grpc::Status SpawnFromPattern(::grpc::ClientContext* context, const ::seshat::SpawnFromPatternRequest& request, ::seshat::SpawnFromPatternResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnFromPatternResponse>> AsyncSpawnFromPattern(::grpc::ClientContext* context, const ::seshat::SpawnFromPatternRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnFromPatternResponse>>(AsyncSpawnFromPatternRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnFromPatternResponse>> PrepareAsyncSpawnFromPattern(::grpc::ClientContext* context, const ::seshat::SpawnFromPatternRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnFromPatternResponse>>(PrepareAsyncSpawnFromPatternRaw(context, request, cq));
    }
    // Spawn patterns and configurations
    virtual ::grpc::Status GetSpawnPatterns(::grpc::ClientContext* context, const ::seshat::GetSpawnPatternsRequest& request, ::seshat::GetSpawnPatternsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnPatternsResponse>> AsyncGetSpawnPatterns(::grpc::ClientContext* context, const ::seshat::GetSpawnPatternsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnPatternsResponse>>(AsyncGetSpawnPatternsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnPatternsResponse>> PrepareAsyncGetSpawnPatterns(::grpc::ClientContext* context, const ::seshat::GetSpawnPatternsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnPatternsResponse>>(PrepareAsyncGetSpawnPatternsRaw(context, request, cq));
    }
    virtual ::grpc::Status CreateSpawnPattern(::grpc::ClientContext* context, const ::seshat::CreateSpawnPatternRequest& request, ::seshat::CreateSpawnPatternResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateSpawnPatternResponse>> AsyncCreateSpawnPattern(::grpc::ClientContext* context, const ::seshat::CreateSpawnPatternRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateSpawnPatternResponse>>(AsyncCreateSpawnPatternRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateSpawnPatternResponse>> PrepareAsyncCreateSpawnPattern(::grpc::ClientContext* context, const ::seshat::CreateSpawnPatternRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateSpawnPatternResponse>>(PrepareAsyncCreateSpawnPatternRaw(context, request, cq));
    }
    virtual ::grpc::Status UpdateSpawnPattern(::grpc::ClientContext* context, const ::seshat::UpdateSpawnPatternRequest& request, ::seshat::UpdateSpawnPatternResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UpdateSpawnPatternResponse>> AsyncUpdateSpawnPattern(::grpc::ClientContext* context, const ::seshat::UpdateSpawnPatternRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UpdateSpawnPatternResponse>>(AsyncUpdateSpawnPatternRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UpdateSpawnPatternResponse>> PrepareAsyncUpdateSpawnPattern(::grpc::ClientContext* context, const ::seshat::UpdateSpawnPatternRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UpdateSpawnPatternResponse>>(PrepareAsyncUpdateSpawnPatternRaw(context, request, cq));
    }
    // Constraint management
    virtual ::grpc::Status AddSpawnConstraint(::grpc::ClientContext* context, const ::seshat::AddSpawnConstraintRequest& request, ::seshat::AddSpawnConstraintResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AddSpawnConstraintResponse>> AsyncAddSpawnConstraint(::grpc::ClientContext* context, const ::seshat::AddSpawnConstraintRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AddSpawnConstraintResponse>>(AsyncAddSpawnConstraintRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AddSpawnConstraintResponse>> PrepareAsyncAddSpawnConstraint(::grpc::ClientContext* context, const ::seshat::AddSpawnConstraintRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AddSpawnConstraintResponse>>(PrepareAsyncAddSpawnConstraintRaw(context, request, cq));
    }
    virtual ::grpc::Status RemoveSpawnConstraint(::grpc::ClientContext* context, const ::seshat::RemoveSpawnConstraintRequest& request, ::seshat::RemoveSpawnConstraintResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RemoveSpawnConstraintResponse>> AsyncRemoveSpawnConstraint(::grpc::ClientContext* context, const ::seshat::RemoveSpawnConstraintRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RemoveSpawnConstraintResponse>>(AsyncRemoveSpawnConstraintRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RemoveSpawnConstraintResponse>> PrepareAsyncRemoveSpawnConstraint(::grpc::ClientContext* context, const ::seshat::RemoveSpawnConstraintRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RemoveSpawnConstraintResponse>>(PrepareAsyncRemoveSpawnConstraintRaw(context, request, cq));
    }
    virtual ::grpc::Status GetSpawnConstraints(::grpc::ClientContext* context, const ::seshat::GetSpawnConstraintsRequest& request, ::seshat::GetSpawnConstraintsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnConstraintsResponse>> AsyncGetSpawnConstraints(::grpc::ClientContext* context, const ::seshat::GetSpawnConstraintsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnConstraintsResponse>>(AsyncGetSpawnConstraintsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnConstraintsResponse>> PrepareAsyncGetSpawnConstraints(::grpc::ClientContext* context, const ::seshat::GetSpawnConstraintsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnConstraintsResponse>>(PrepareAsyncGetSpawnConstraintsRaw(context, request, cq));
    }
    virtual ::grpc::Status ValidateSpawnPosition(::grpc::ClientContext* context, const ::seshat::ValidateSpawnPositionRequest& request, ::seshat::ValidateSpawnPositionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ValidateSpawnPositionResponse>> AsyncValidateSpawnPosition(::grpc::ClientContext* context, const ::seshat::ValidateSpawnPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ValidateSpawnPositionResponse>>(AsyncValidateSpawnPositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ValidateSpawnPositionResponse>> PrepareAsyncValidateSpawnPosition(::grpc::ClientContext* context, const ::seshat::ValidateSpawnPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ValidateSpawnPositionResponse>>(PrepareAsyncValidateSpawnPositionRaw(context, request, cq));
    }
    // Capacity analysis and optimization
    virtual ::grpc::Status AnalyzeSpawnCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeSpawnCapacityRequest& request, ::seshat::AnalyzeSpawnCapacityResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AnalyzeSpawnCapacityResponse>> AsyncAnalyzeSpawnCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeSpawnCapacityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AnalyzeSpawnCapacityResponse>>(AsyncAnalyzeSpawnCapacityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AnalyzeSpawnCapacityResponse>> PrepareAsyncAnalyzeSpawnCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeSpawnCapacityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AnalyzeSpawnCapacityResponse>>(PrepareAsyncAnalyzeSpawnCapacityRaw(context, request, cq));
    }
    virtual ::grpc::Status GetOptimalSpawnPositions(::grpc::ClientContext* context, const ::seshat::GetOptimalSpawnPositionsRequest& request, ::seshat::GetOptimalSpawnPositionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetOptimalSpawnPositionsResponse>> AsyncGetOptimalSpawnPositions(::grpc::ClientContext* context, const ::seshat::GetOptimalSpawnPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetOptimalSpawnPositionsResponse>>(AsyncGetOptimalSpawnPositionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetOptimalSpawnPositionsResponse>> PrepareAsyncGetOptimalSpawnPositions(::grpc::ClientContext* context, const ::seshat::GetOptimalSpawnPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetOptimalSpawnPositionsResponse>>(PrepareAsyncGetOptimalSpawnPositionsRaw(context, request, cq));
    }
    virtual ::grpc::Status RecommendRoomSplit(::grpc::ClientContext* context, const ::seshat::RecommendRoomSplitRequest& request, ::seshat::RecommendRoomSplitResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RecommendRoomSplitResponse>> AsyncRecommendRoomSplit(::grpc::ClientContext* context, const ::seshat::RecommendRoomSplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RecommendRoomSplitResponse>>(AsyncRecommendRoomSplitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RecommendRoomSplitResponse>> PrepareAsyncRecommendRoomSplit(::grpc::ClientContext* context, const ::seshat::RecommendRoomSplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RecommendRoomSplitResponse>>(PrepareAsyncRecommendRoomSplitRaw(context, request, cq));
    }
    // Spawn history and tracking
    virtual ::grpc::Status GetSpawnHistory(::grpc::ClientContext* context, const ::seshat::GetSpawnHistoryRequest& request, ::seshat::GetSpawnHistoryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnHistoryResponse>> AsyncGetSpawnHistory(::grpc::ClientContext* context, const ::seshat::GetSpawnHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnHistoryResponse>>(AsyncGetSpawnHistoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnHistoryResponse>> PrepareAsyncGetSpawnHistory(::grpc::ClientContext* context, const ::seshat::GetSpawnHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnHistoryResponse>>(PrepareAsyncGetSpawnHistoryRaw(context, request, cq));
    }
    virtual ::grpc::Status GetActiveSpawns(::grpc::ClientContext* context, const ::seshat::GetActiveSpawnsRequest& request, ::seshat::GetActiveSpawnsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetActiveSpawnsResponse>> AsyncGetActiveSpawns(::grpc::ClientContext* context, const ::seshat::GetActiveSpawnsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetActiveSpawnsResponse>>(AsyncGetActiveSpawnsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetActiveSpawnsResponse>> PrepareAsyncGetActiveSpawns(::grpc::ClientContext* context, const ::seshat::GetActiveSpawnsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetActiveSpawnsResponse>>(PrepareAsyncGetActiveSpawnsRaw(context, request, cq));
    }
    virtual ::grpc::Status DespawnEntity(::grpc::ClientContext* context, const ::seshat::DespawnEntityRequest& request, ::seshat::DespawnEntityResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DespawnEntityResponse>> AsyncDespawnEntity(::grpc::ClientContext* context, const ::seshat::DespawnEntityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DespawnEntityResponse>>(AsyncDespawnEntityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DespawnEntityResponse>> PrepareAsyncDespawnEntity(::grpc::ClientContext* context, const ::seshat::DespawnEntityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DespawnEntityResponse>>(PrepareAsyncDespawnEntityRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Spawn engine management
      virtual void CreateSpawnEngine(::grpc::ClientContext* context, const ::seshat::CreateSpawnEngineRequest* request, ::seshat::CreateSpawnEngineResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateSpawnEngine(::grpc::ClientContext* context, const ::seshat::CreateSpawnEngineRequest* request, ::seshat::CreateSpawnEngineResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSpawnEngine(::grpc::ClientContext* context, const ::seshat::GetSpawnEngineRequest* request, ::seshat::GetSpawnEngineResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSpawnEngine(::grpc::ClientContext* context, const ::seshat::GetSpawnEngineRequest* request, ::seshat::GetSpawnEngineResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DeleteSpawnEngine(::grpc::ClientContext* context, const ::seshat::DeleteSpawnEngineRequest* request, ::seshat::DeleteSpawnEngineResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteSpawnEngine(::grpc::ClientContext* context, const ::seshat::DeleteSpawnEngineRequest* request, ::seshat::DeleteSpawnEngineResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Entity spawning
      virtual void SpawnEntity(::grpc::ClientContext* context, const ::seshat::SpawnEntityRequest* request, ::seshat::SpawnEntityResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SpawnEntity(::grpc::ClientContext* context, const ::seshat::SpawnEntityRequest* request, ::seshat::SpawnEntityResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SpawnMultipleEntities(::grpc::ClientContext* context, const ::seshat::SpawnMultipleEntitiesRequest* request, ::seshat::SpawnMultipleEntitiesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SpawnMultipleEntities(::grpc::ClientContext* context, const ::seshat::SpawnMultipleEntitiesRequest* request, ::seshat::SpawnMultipleEntitiesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SpawnFromPattern(::grpc::ClientContext* context, const ::seshat::SpawnFromPatternRequest* request, ::seshat::SpawnFromPatternResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SpawnFromPattern(::grpc::ClientContext* context, const ::seshat::SpawnFromPatternRequest* request, ::seshat::SpawnFromPatternResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Spawn patterns and configurations
      virtual void GetSpawnPatterns(::grpc::ClientContext* context, const ::seshat::GetSpawnPatternsRequest* request, ::seshat::GetSpawnPatternsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSpawnPatterns(::grpc::ClientContext* context, const ::seshat::GetSpawnPatternsRequest* request, ::seshat::GetSpawnPatternsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CreateSpawnPattern(::grpc::ClientContext* context, const ::seshat::CreateSpawnPatternRequest* request, ::seshat::CreateSpawnPatternResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateSpawnPattern(::grpc::ClientContext* context, const ::seshat::CreateSpawnPatternRequest* request, ::seshat::CreateSpawnPatternResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateSpawnPattern(::grpc::ClientContext* context, const ::seshat::UpdateSpawnPatternRequest* request, ::seshat::UpdateSpawnPatternResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateSpawnPattern(::grpc::ClientContext* context, const ::seshat::UpdateSpawnPatternRequest* request, ::seshat::UpdateSpawnPatternResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Constraint management
      virtual void AddSpawnConstraint(::grpc::ClientContext* context, const ::seshat::AddSpawnConstraintRequest* request, ::seshat::AddSpawnConstraintResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AddSpawnConstraint(::grpc::ClientContext* context, const ::seshat::AddSpawnConstraintRequest* request, ::seshat::AddSpawnConstraintResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void RemoveSpawnConstraint(::grpc::ClientContext* context, const ::seshat::RemoveSpawnConstraintRequest* request, ::seshat::RemoveSpawnConstraintResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RemoveSpawnConstraint(::grpc::ClientContext* context, const ::seshat::RemoveSpawnConstraintRequest* request, ::seshat::RemoveSpawnConstraintResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetSpawnConstraints(::grpc::ClientContext* context, const ::seshat::GetSpawnConstraintsRequest* request, ::seshat::GetSpawnConstraintsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSpawnConstraints(::grpc::ClientContext* context, const ::seshat::GetSpawnConstraintsRequest* request, ::seshat::GetSpawnConstraintsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ValidateSpawnPosition(::grpc::ClientContext* context, const ::seshat::ValidateSpawnPositionRequest* request, ::seshat::ValidateSpawnPositionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ValidateSpawnPosition(::grpc::ClientContext* context, const ::seshat::ValidateSpawnPositionRequest* request, ::seshat::ValidateSpawnPositionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Capacity analysis and optimization
      virtual void AnalyzeSpawnCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeSpawnCapacityRequest* request, ::seshat::AnalyzeSpawnCapacityResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AnalyzeSpawnCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeSpawnCapacityRequest* request, ::seshat::AnalyzeSpawnCapacityResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetOptimalSpawnPositions(::grpc::ClientContext* context, const ::seshat::GetOptimalSpawnPositionsRequest* request, ::seshat::GetOptimalSpawnPositionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetOptimalSpawnPositions(::grpc::ClientContext* context, const ::seshat::GetOptimalSpawnPositionsRequest* request, ::seshat::GetOptimalSpawnPositionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void RecommendRoomSplit(::grpc::ClientContext* context, const ::seshat::RecommendRoomSplitRequest* request, ::seshat::RecommendRoomSplitResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RecommendRoomSplit(::grpc::ClientContext* context, const ::seshat::RecommendRoomSplitRequest* request, ::seshat::RecommendRoomSplitResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Spawn history and tracking
      virtual void GetSpawnHistory(::grpc::ClientContext* context, const ::seshat::GetSpawnHistoryRequest* request, ::seshat::GetSpawnHistoryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSpawnHistory(::grpc::ClientContext* context, const ::seshat::GetSpawnHistoryRequest* request, ::seshat::GetSpawnHistoryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetActiveSpawns(::grpc::ClientContext* context, const ::seshat::GetActiveSpawnsRequest* request, ::seshat::GetActiveSpawnsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetActiveSpawns(::grpc::ClientContext* context, const ::seshat::GetActiveSpawnsRequest* request, ::seshat::GetActiveSpawnsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DespawnEntity(::grpc::ClientContext* context, const ::seshat::DespawnEntityRequest* request, ::seshat::DespawnEntityResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DespawnEntity(::grpc::ClientContext* context, const ::seshat::DespawnEntityRequest* request, ::seshat::DespawnEntityResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateSpawnEngineResponse>* AsyncCreateSpawnEngineRaw(::grpc::ClientContext* context, const ::seshat::CreateSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateSpawnEngineResponse>* PrepareAsyncCreateSpawnEngineRaw(::grpc::ClientContext* context, const ::seshat::CreateSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnEngineResponse>* AsyncGetSpawnEngineRaw(::grpc::ClientContext* context, const ::seshat::GetSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnEngineResponse>* PrepareAsyncGetSpawnEngineRaw(::grpc::ClientContext* context, const ::seshat::GetSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DeleteSpawnEngineResponse>* AsyncDeleteSpawnEngineRaw(::grpc::ClientContext* context, const ::seshat::DeleteSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DeleteSpawnEngineResponse>* PrepareAsyncDeleteSpawnEngineRaw(::grpc::ClientContext* context, const ::seshat::DeleteSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnEntityResponse>* AsyncSpawnEntityRaw(::grpc::ClientContext* context, const ::seshat::SpawnEntityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnEntityResponse>* PrepareAsyncSpawnEntityRaw(::grpc::ClientContext* context, const ::seshat::SpawnEntityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnMultipleEntitiesResponse>* AsyncSpawnMultipleEntitiesRaw(::grpc::ClientContext* context, const ::seshat::SpawnMultipleEntitiesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnMultipleEntitiesResponse>* PrepareAsyncSpawnMultipleEntitiesRaw(::grpc::ClientContext* context, const ::seshat::SpawnMultipleEntitiesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnFromPatternResponse>* AsyncSpawnFromPatternRaw(::grpc::ClientContext* context, const ::seshat::SpawnFromPatternRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::SpawnFromPatternResponse>* PrepareAsyncSpawnFromPatternRaw(::grpc::ClientContext* context, const ::seshat::SpawnFromPatternRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnPatternsResponse>* AsyncGetSpawnPatternsRaw(::grpc::ClientContext* context, const ::seshat::GetSpawnPatternsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnPatternsResponse>* PrepareAsyncGetSpawnPatternsRaw(::grpc::ClientContext* context, const ::seshat::GetSpawnPatternsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateSpawnPatternResponse>* AsyncCreateSpawnPatternRaw(::grpc::ClientContext* context, const ::seshat::CreateSpawnPatternRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateSpawnPatternResponse>* PrepareAsyncCreateSpawnPatternRaw(::grpc::ClientContext* context, const ::seshat::CreateSpawnPatternRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UpdateSpawnPatternResponse>* AsyncUpdateSpawnPatternRaw(::grpc::ClientContext* context, const ::seshat::UpdateSpawnPatternRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UpdateSpawnPatternResponse>* PrepareAsyncUpdateSpawnPatternRaw(::grpc::ClientContext* context, const ::seshat::UpdateSpawnPatternRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AddSpawnConstraintResponse>* AsyncAddSpawnConstraintRaw(::grpc::ClientContext* context, const ::seshat::AddSpawnConstraintRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AddSpawnConstraintResponse>* PrepareAsyncAddSpawnConstraintRaw(::grpc::ClientContext* context, const ::seshat::AddSpawnConstraintRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RemoveSpawnConstraintResponse>* AsyncRemoveSpawnConstraintRaw(::grpc::ClientContext* context, const ::seshat::RemoveSpawnConstraintRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RemoveSpawnConstraintResponse>* PrepareAsyncRemoveSpawnConstraintRaw(::grpc::ClientContext* context, const ::seshat::RemoveSpawnConstraintRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnConstraintsResponse>* AsyncGetSpawnConstraintsRaw(::grpc::ClientContext* context, const ::seshat::GetSpawnConstraintsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnConstraintsResponse>* PrepareAsyncGetSpawnConstraintsRaw(::grpc::ClientContext* context, const ::seshat::GetSpawnConstraintsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ValidateSpawnPositionResponse>* AsyncValidateSpawnPositionRaw(::grpc::ClientContext* context, const ::seshat::ValidateSpawnPositionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ValidateSpawnPositionResponse>* PrepareAsyncValidateSpawnPositionRaw(::grpc::ClientContext* context, const ::seshat::ValidateSpawnPositionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AnalyzeSpawnCapacityResponse>* AsyncAnalyzeSpawnCapacityRaw(::grpc::ClientContext* context, const ::seshat::AnalyzeSpawnCapacityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AnalyzeSpawnCapacityResponse>* PrepareAsyncAnalyzeSpawnCapacityRaw(::grpc::ClientContext* context, const ::seshat::AnalyzeSpawnCapacityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetOptimalSpawnPositionsResponse>* AsyncGetOptimalSpawnPositionsRaw(::grpc::ClientContext* context, const ::seshat::GetOptimalSpawnPositionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetOptimalSpawnPositionsResponse>* PrepareAsyncGetOptimalSpawnPositionsRaw(::grpc::ClientContext* context, const ::seshat::GetOptimalSpawnPositionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RecommendRoomSplitResponse>* AsyncRecommendRoomSplitRaw(::grpc::ClientContext* context, const ::seshat::RecommendRoomSplitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::RecommendRoomSplitResponse>* PrepareAsyncRecommendRoomSplitRaw(::grpc::ClientContext* context, const ::seshat::RecommendRoomSplitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnHistoryResponse>* AsyncGetSpawnHistoryRaw(::grpc::ClientContext* context, const ::seshat::GetSpawnHistoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSpawnHistoryResponse>* PrepareAsyncGetSpawnHistoryRaw(::grpc::ClientContext* context, const ::seshat::GetSpawnHistoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetActiveSpawnsResponse>* AsyncGetActiveSpawnsRaw(::grpc::ClientContext* context, const ::seshat::GetActiveSpawnsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetActiveSpawnsResponse>* PrepareAsyncGetActiveSpawnsRaw(::grpc::ClientContext* context, const ::seshat::GetActiveSpawnsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DespawnEntityResponse>* AsyncDespawnEntityRaw(::grpc::ClientContext* context, const ::seshat::DespawnEntityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DespawnEntityResponse>* PrepareAsyncDespawnEntityRaw(::grpc::ClientContext* context, const ::seshat::DespawnEntityRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status CreateSpawnEngine(::grpc::ClientContext* context, const ::seshat::CreateSpawnEngineRequest& request, ::seshat::CreateSpawnEngineResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CreateSpawnEngineResponse>> AsyncCreateSpawnEngine(::grpc::ClientContext* context, const ::seshat::CreateSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CreateSpawnEngineResponse>>(AsyncCreateSpawnEngineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CreateSpawnEngineResponse>> PrepareAsyncCreateSpawnEngine(::grpc::ClientContext* context, const ::seshat::CreateSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CreateSpawnEngineResponse>>(PrepareAsyncCreateSpawnEngineRaw(context, request, cq));
    }
    ::grpc::Status GetSpawnEngine(::grpc::ClientContext* context, const ::seshat::GetSpawnEngineRequest& request, ::seshat::GetSpawnEngineResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnEngineResponse>> AsyncGetSpawnEngine(::grpc::ClientContext* context, const ::seshat::GetSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnEngineResponse>>(AsyncGetSpawnEngineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnEngineResponse>> PrepareAsyncGetSpawnEngine(::grpc::ClientContext* context, const ::seshat::GetSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnEngineResponse>>(PrepareAsyncGetSpawnEngineRaw(context, request, cq));
    }
    ::grpc::Status DeleteSpawnEngine(::grpc::ClientContext* context, const ::seshat::DeleteSpawnEngineRequest& request, ::seshat::DeleteSpawnEngineResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::DeleteSpawnEngineResponse>> AsyncDeleteSpawnEngine(::grpc::ClientContext* context, const ::seshat::DeleteSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::DeleteSpawnEngineResponse>>(AsyncDeleteSpawnEngineRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::DeleteSpawnEngineResponse>> PrepareAsyncDeleteSpawnEngine(::grpc::ClientContext* context, const ::seshat::DeleteSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::DeleteSpawnEngineResponse>>(PrepareAsyncDeleteSpawnEngineRaw(context, request, cq));
    }
    ::grpc::Status SpawnEntity(::grpc::ClientContext* context, const ::seshat::SpawnEntityRequest& request, ::seshat::SpawnEntityResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::SpawnEntityResponse>> AsyncSpawnEntity(::grpc::ClientContext* context, const ::seshat::SpawnEntityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::SpawnEntityResponse>>(AsyncSpawnEntityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::SpawnEntityResponse>> PrepareAsyncSpawnEntity(::grpc::ClientContext* context, const ::seshat::SpawnEntityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::SpawnEntityResponse>>(PrepareAsyncSpawnEntityRaw(context, request, cq));
    }
    ::grpc::Status SpawnMultipleEntities(::grpc::ClientContext* context, const ::seshat::SpawnMultipleEntitiesRequest& request, ::seshat::SpawnMultipleEntitiesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::SpawnMultipleEntitiesResponse>> AsyncSpawnMultipleEntities(::grpc::ClientContext* context, const ::seshat::SpawnMultipleEntitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::SpawnMultipleEntitiesResponse>>(AsyncSpawnMultipleEntitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::SpawnMultipleEntitiesResponse>> PrepareAsyncSpawnMultipleEntities(::grpc::ClientContext* context, const ::seshat::SpawnMultipleEntitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::SpawnMultipleEntitiesResponse>>(PrepareAsyncSpawnMultipleEntitiesRaw(context, request, cq));
    }
    ::grpc::Status SpawnFromPattern(::grpc::ClientContext* context, const ::seshat::SpawnFromPatternRequest& request, ::seshat::SpawnFromPatternResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::SpawnFromPatternResponse>> AsyncSpawnFromPattern(::grpc::ClientContext* context, const ::seshat::SpawnFromPatternRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::SpawnFromPatternResponse>>(AsyncSpawnFromPatternRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::SpawnFromPatternResponse>> PrepareAsyncSpawnFromPattern(::grpc::ClientContext* context, const ::seshat::SpawnFromPatternRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::SpawnFromPatternResponse>>(PrepareAsyncSpawnFromPatternRaw(context, request, cq));
    }
    ::grpc::Status GetSpawnPatterns(::grpc::ClientContext* context, const ::seshat::GetSpawnPatternsRequest& request, ::seshat::GetSpawnPatternsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnPatternsResponse>> AsyncGetSpawnPatterns(::grpc::ClientContext* context, const ::seshat::GetSpawnPatternsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnPatternsResponse>>(AsyncGetSpawnPatternsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnPatternsResponse>> PrepareAsyncGetSpawnPatterns(::grpc::ClientContext* context, const ::seshat::GetSpawnPatternsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnPatternsResponse>>(PrepareAsyncGetSpawnPatternsRaw(context, request, cq));
    }
    ::grpc::Status CreateSpawnPattern(::grpc::ClientContext* context, const ::seshat::CreateSpawnPatternRequest& request, ::seshat::CreateSpawnPatternResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CreateSpawnPatternResponse>> AsyncCreateSpawnPattern(::grpc::ClientContext* context, const ::seshat::CreateSpawnPatternRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CreateSpawnPatternResponse>>(AsyncCreateSpawnPatternRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CreateSpawnPatternResponse>> PrepareAsyncCreateSpawnPattern(::grpc::ClientContext* context, const ::seshat::CreateSpawnPatternRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CreateSpawnPatternResponse>>(PrepareAsyncCreateSpawnPatternRaw(context, request, cq));
    }
    ::grpc::Status UpdateSpawnPattern(::grpc::ClientContext* context, const ::seshat::UpdateSpawnPatternRequest& request, ::seshat::UpdateSpawnPatternResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::UpdateSpawnPatternResponse>> AsyncUpdateSpawnPattern(::grpc::ClientContext* context, const ::seshat::UpdateSpawnPatternRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::UpdateSpawnPatternResponse>>(AsyncUpdateSpawnPatternRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::UpdateSpawnPatternResponse>> PrepareAsyncUpdateSpawnPattern(::grpc::ClientContext* context, const ::seshat::UpdateSpawnPatternRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::UpdateSpawnPatternResponse>>(PrepareAsyncUpdateSpawnPatternRaw(context, request, cq));
    }
    ::grpc::Status AddSpawnConstraint(::grpc::ClientContext* context, const ::seshat::AddSpawnConstraintRequest& request, ::seshat::AddSpawnConstraintResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::AddSpawnConstraintResponse>> AsyncAddSpawnConstraint(::grpc::ClientContext* context, const ::seshat::AddSpawnConstraintRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::AddSpawnConstraintResponse>>(AsyncAddSpawnConstraintRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::AddSpawnConstraintResponse>> PrepareAsyncAddSpawnConstraint(::grpc::ClientContext* context, const ::seshat::AddSpawnConstraintRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::AddSpawnConstraintResponse>>(PrepareAsyncAddSpawnConstraintRaw(context, request, cq));
    }
    ::grpc::Status RemoveSpawnConstraint(::grpc::ClientContext* context, const ::seshat::RemoveSpawnConstraintRequest& request, ::seshat::RemoveSpawnConstraintResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::RemoveSpawnConstraintResponse>> AsyncRemoveSpawnConstraint(::grpc::ClientContext* context, const ::seshat::RemoveSpawnConstraintRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::RemoveSpawnConstraintResponse>>(AsyncRemoveSpawnConstraintRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::RemoveSpawnConstraintResponse>> PrepareAsyncRemoveSpawnConstraint(::grpc::ClientContext* context, const ::seshat::RemoveSpawnConstraintRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::RemoveSpawnConstraintResponse>>(PrepareAsyncRemoveSpawnConstraintRaw(context, request, cq));
    }
    ::grpc::Status GetSpawnConstraints(::grpc::ClientContext* context, const ::seshat::GetSpawnConstraintsRequest& request, ::seshat::GetSpawnConstraintsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnConstraintsResponse>> AsyncGetSpawnConstraints(::grpc::ClientContext* context, const ::seshat::GetSpawnConstraintsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnConstraintsResponse>>(AsyncGetSpawnConstraintsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnConstraintsResponse>> PrepareAsyncGetSpawnConstraints(::grpc::ClientContext* context, const ::seshat::GetSpawnConstraintsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnConstraintsResponse>>(PrepareAsyncGetSpawnConstraintsRaw(context, request, cq));
    }
    ::grpc::Status ValidateSpawnPosition(::grpc::ClientContext* context, const ::seshat::ValidateSpawnPositionRequest& request, ::seshat::ValidateSpawnPositionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ValidateSpawnPositionResponse>> AsyncValidateSpawnPosition(::grpc::ClientContext* context, const ::seshat::ValidateSpawnPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ValidateSpawnPositionResponse>>(AsyncValidateSpawnPositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ValidateSpawnPositionResponse>> PrepareAsyncValidateSpawnPosition(::grpc::ClientContext* context, const ::seshat::ValidateSpawnPositionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ValidateSpawnPositionResponse>>(PrepareAsyncValidateSpawnPositionRaw(context, request, cq));
    }
    ::grpc::Status AnalyzeSpawnCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeSpawnCapacityRequest& request, ::seshat::AnalyzeSpawnCapacityResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::AnalyzeSpawnCapacityResponse>> AsyncAnalyzeSpawnCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeSpawnCapacityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::AnalyzeSpawnCapacityResponse>>(AsyncAnalyzeSpawnCapacityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::AnalyzeSpawnCapacityResponse>> PrepareAsyncAnalyzeSpawnCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeSpawnCapacityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::AnalyzeSpawnCapacityResponse>>(PrepareAsyncAnalyzeSpawnCapacityRaw(context, request, cq));
    }
    ::grpc::Status GetOptimalSpawnPositions(::grpc::ClientContext* context, const ::seshat::GetOptimalSpawnPositionsRequest& request, ::seshat::GetOptimalSpawnPositionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetOptimalSpawnPositionsResponse>> AsyncGetOptimalSpawnPositions(::grpc::ClientContext* context, const ::seshat::GetOptimalSpawnPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetOptimalSpawnPositionsResponse>>(AsyncGetOptimalSpawnPositionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetOptimalSpawnPositionsResponse>> PrepareAsyncGetOptimalSpawnPositions(::grpc::ClientContext* context, const ::seshat::GetOptimalSpawnPositionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetOptimalSpawnPositionsResponse>>(PrepareAsyncGetOptimalSpawnPositionsRaw(context, request, cq));
    }
    ::grpc::Status RecommendRoomSplit(::grpc::ClientContext* context, const ::seshat::RecommendRoomSplitRequest& request, ::seshat::RecommendRoomSplitResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::RecommendRoomSplitResponse>> AsyncRecommendRoomSplit(::grpc::ClientContext* context, const ::seshat::RecommendRoomSplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::RecommendRoomSplitResponse>>(AsyncRecommendRoomSplitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::RecommendRoomSplitResponse>> PrepareAsyncRecommendRoomSplit(::grpc::ClientContext* context, const ::seshat::RecommendRoomSplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::RecommendRoomSplitResponse>>(PrepareAsyncRecommendRoomSplitRaw(context, request, cq));
    }
    ::grpc::Status GetSpawnHistory(::grpc::ClientContext* context, const ::seshat::GetSpawnHistoryRequest& request, ::seshat::GetSpawnHistoryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnHistoryResponse>> AsyncGetSpawnHistory(::grpc::ClientContext* context, const ::seshat::GetSpawnHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnHistoryResponse>>(AsyncGetSpawnHistoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnHistoryResponse>> PrepareAsyncGetSpawnHistory(::grpc::ClientContext* context, const ::seshat::GetSpawnHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnHistoryResponse>>(PrepareAsyncGetSpawnHistoryRaw(context, request, cq));
    }
    ::grpc::Status GetActiveSpawns(::grpc::ClientContext* context, const ::seshat::GetActiveSpawnsRequest& request, ::seshat::GetActiveSpawnsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetActiveSpawnsResponse>> AsyncGetActiveSpawns(::grpc::ClientContext* context, const ::seshat::GetActiveSpawnsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetActiveSpawnsResponse>>(AsyncGetActiveSpawnsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetActiveSpawnsResponse>> PrepareAsyncGetActiveSpawns(::grpc::ClientContext* context, const ::seshat::GetActiveSpawnsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetActiveSpawnsResponse>>(PrepareAsyncGetActiveSpawnsRaw(context, request, cq));
    }
    ::grpc::Status DespawnEntity(::grpc::ClientContext* context, const ::seshat::DespawnEntityRequest& request, ::seshat::DespawnEntityResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::DespawnEntityResponse>> AsyncDespawnEntity(::grpc::ClientContext* context, const ::seshat::DespawnEntityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::DespawnEntityResponse>>(AsyncDespawnEntityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::DespawnEntityResponse>> PrepareAsyncDespawnEntity(::grpc::ClientContext* context, const ::seshat::DespawnEntityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::DespawnEntityResponse>>(PrepareAsyncDespawnEntityRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void CreateSpawnEngine(::grpc::ClientContext* context, const ::seshat::CreateSpawnEngineRequest* request, ::seshat::CreateSpawnEngineResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateSpawnEngine(::grpc::ClientContext* context, const ::seshat::CreateSpawnEngineRequest* request, ::seshat::CreateSpawnEngineResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSpawnEngine(::grpc::ClientContext* context, const ::seshat::GetSpawnEngineRequest* request, ::seshat::GetSpawnEngineResponse* response, std::function<void(::grpc::Status)>) override;
      void GetSpawnEngine(::grpc::ClientContext* context, const ::seshat::GetSpawnEngineRequest* request, ::seshat::GetSpawnEngineResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DeleteSpawnEngine(::grpc::ClientContext* context, const ::seshat::DeleteSpawnEngineRequest* request, ::seshat::DeleteSpawnEngineResponse* response, std::function<void(::grpc::Status)>) override;
      void DeleteSpawnEngine(::grpc::ClientContext* context, const ::seshat::DeleteSpawnEngineRequest* request, ::seshat::DeleteSpawnEngineResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SpawnEntity(::grpc::ClientContext* context, const ::seshat::SpawnEntityRequest* request, ::seshat::SpawnEntityResponse* response, std::function<void(::grpc::Status)>) override;
      void SpawnEntity(::grpc::ClientContext* context, const ::seshat::SpawnEntityRequest* request, ::seshat::SpawnEntityResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SpawnMultipleEntities(::grpc::ClientContext* context, const ::seshat::SpawnMultipleEntitiesRequest* request, ::seshat::SpawnMultipleEntitiesResponse* response, std::function<void(::grpc::Status)>) override;
      void SpawnMultipleEntities(::grpc::ClientContext* context, const ::seshat::SpawnMultipleEntitiesRequest* request, ::seshat::SpawnMultipleEntitiesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SpawnFromPattern(::grpc::ClientContext* context, const ::seshat::SpawnFromPatternRequest* request, ::seshat::SpawnFromPatternResponse* response, std::function<void(::grpc::Status)>) override;
      void SpawnFromPattern(::grpc::ClientContext* context, const ::seshat::SpawnFromPatternRequest* request, ::seshat::SpawnFromPatternResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSpawnPatterns(::grpc::ClientContext* context, const ::seshat::GetSpawnPatternsRequest* request, ::seshat::GetSpawnPatternsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetSpawnPatterns(::grpc::ClientContext* context, const ::seshat::GetSpawnPatternsRequest* request, ::seshat::GetSpawnPatternsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreateSpawnPattern(::grpc::ClientContext* context, const ::seshat::CreateSpawnPatternRequest* request, ::seshat::CreateSpawnPatternResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateSpawnPattern(::grpc::ClientContext* context, const ::seshat::CreateSpawnPatternRequest* request, ::seshat::CreateSpawnPatternResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateSpawnPattern(::grpc::ClientContext* context, const ::seshat::UpdateSpawnPatternRequest* request, ::seshat::UpdateSpawnPatternResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateSpawnPattern(::grpc::ClientContext* context, const ::seshat::UpdateSpawnPatternRequest* request, ::seshat::UpdateSpawnPatternResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AddSpawnConstraint(::grpc::ClientContext* context, const ::seshat::AddSpawnConstraintRequest* request, ::seshat::AddSpawnConstraintResponse* response, std::function<void(::grpc::Status)>) override;
      void AddSpawnConstraint(::grpc::ClientContext* context, const ::seshat::AddSpawnConstraintRequest* request, ::seshat::AddSpawnConstraintResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RemoveSpawnConstraint(::grpc::ClientContext* context, const ::seshat::RemoveSpawnConstraintRequest* request, ::seshat::RemoveSpawnConstraintResponse* response, std::function<void(::grpc::Status)>) override;
      void RemoveSpawnConstraint(::grpc::ClientContext* context, const ::seshat::RemoveSpawnConstraintRequest* request, ::seshat::RemoveSpawnConstraintResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSpawnConstraints(::grpc::ClientContext* context, const ::seshat::GetSpawnConstraintsRequest* request, ::seshat::GetSpawnConstraintsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetSpawnConstraints(::grpc::ClientContext* context, const ::seshat::GetSpawnConstraintsRequest* request, ::seshat::GetSpawnConstraintsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ValidateSpawnPosition(::grpc::ClientContext* context, const ::seshat::ValidateSpawnPositionRequest* request, ::seshat::ValidateSpawnPositionResponse* response, std::function<void(::grpc::Status)>) override;
      void ValidateSpawnPosition(::grpc::ClientContext* context, const ::seshat::ValidateSpawnPositionRequest* request, ::seshat::ValidateSpawnPositionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AnalyzeSpawnCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeSpawnCapacityRequest* request, ::seshat::AnalyzeSpawnCapacityResponse* response, std::function<void(::grpc::Status)>) override;
      void AnalyzeSpawnCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeSpawnCapacityRequest* request, ::seshat::AnalyzeSpawnCapacityResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetOptimalSpawnPositions(::grpc::ClientContext* context, const ::seshat::GetOptimalSpawnPositionsRequest* request, ::seshat::GetOptimalSpawnPositionsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetOptimalSpawnPositions(::grpc::ClientContext* context, const ::seshat::GetOptimalSpawnPositionsRequest* request, ::seshat::GetOptimalSpawnPositionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RecommendRoomSplit(::grpc::ClientContext* context, const ::seshat::RecommendRoomSplitRequest* request, ::seshat::RecommendRoomSplitResponse* response, std::function<void(::grpc::Status)>) override;
      void RecommendRoomSplit(::grpc::ClientContext* context, const ::seshat::RecommendRoomSplitRequest* request, ::seshat::RecommendRoomSplitResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSpawnHistory(::grpc::ClientContext* context, const ::seshat::GetSpawnHistoryRequest* request, ::seshat::GetSpawnHistoryResponse* response, std::function<void(::grpc::Status)>) override;
      void GetSpawnHistory(::grpc::ClientContext* context, const ::seshat::GetSpawnHistoryRequest* request, ::seshat::GetSpawnHistoryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetActiveSpawns(::grpc::ClientContext* context, const ::seshat::GetActiveSpawnsRequest* request, ::seshat::GetActiveSpawnsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetActiveSpawns(::grpc::ClientContext* context, const ::seshat::GetActiveSpawnsRequest* request, ::seshat::GetActiveSpawnsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DespawnEntity(::grpc::ClientContext* context, const ::seshat::DespawnEntityRequest* request, ::seshat::DespawnEntityResponse* response, std::function<void(::grpc::Status)>) override;
      void DespawnEntity(::grpc::ClientContext* context, const ::seshat::DespawnEntityRequest* request, ::seshat::DespawnEntityResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::seshat::CreateSpawnEngineResponse>* AsyncCreateSpawnEngineRaw(::grpc::ClientContext* context, const ::seshat::CreateSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::CreateSpawnEngineResponse>* PrepareAsyncCreateSpawnEngineRaw(::grpc::ClientContext* context, const ::seshat::CreateSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnEngineResponse>* AsyncGetSpawnEngineRaw(::grpc::ClientContext* context, const ::seshat::GetSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnEngineResponse>* PrepareAsyncGetSpawnEngineRaw(::grpc::ClientContext* context, const ::seshat::GetSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::DeleteSpawnEngineResponse>* AsyncDeleteSpawnEngineRaw(::grpc::ClientContext* context, const ::seshat::DeleteSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::DeleteSpawnEngineResponse>* PrepareAsyncDeleteSpawnEngineRaw(::grpc::ClientContext* context, const ::seshat::DeleteSpawnEngineRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::SpawnEntityResponse>* AsyncSpawnEntityRaw(::grpc::ClientContext* context, const ::seshat::SpawnEntityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::SpawnEntityResponse>* PrepareAsyncSpawnEntityRaw(::grpc::ClientContext* context, const ::seshat::SpawnEntityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::SpawnMultipleEntitiesResponse>* AsyncSpawnMultipleEntitiesRaw(::grpc::ClientContext* context, const ::seshat::SpawnMultipleEntitiesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::SpawnMultipleEntitiesResponse>* PrepareAsyncSpawnMultipleEntitiesRaw(::grpc::ClientContext* context, const ::seshat::SpawnMultipleEntitiesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::SpawnFromPatternResponse>* AsyncSpawnFromPatternRaw(::grpc::ClientContext* context, const ::seshat::SpawnFromPatternRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::SpawnFromPatternResponse>* PrepareAsyncSpawnFromPatternRaw(::grpc::ClientContext* context, const ::seshat::SpawnFromPatternRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnPatternsResponse>* AsyncGetSpawnPatternsRaw(::grpc::ClientContext* context, const ::seshat::GetSpawnPatternsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnPatternsResponse>* PrepareAsyncGetSpawnPatternsRaw(::grpc::ClientContext* context, const ::seshat::GetSpawnPatternsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::CreateSpawnPatternResponse>* AsyncCreateSpawnPatternRaw(::grpc::ClientContext* context, const ::seshat::CreateSpawnPatternRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::CreateSpawnPatternResponse>* PrepareAsyncCreateSpawnPatternRaw(::grpc::ClientContext* context, const ::seshat::CreateSpawnPatternRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::UpdateSpawnPatternResponse>* AsyncUpdateSpawnPatternRaw(::grpc::ClientContext* context, const ::seshat::UpdateSpawnPatternRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::UpdateSpawnPatternResponse>* PrepareAsyncUpdateSpawnPatternRaw(::grpc::ClientContext* context, const ::seshat::UpdateSpawnPatternRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::AddSpawnConstraintResponse>* AsyncAddSpawnConstraintRaw(::grpc::ClientContext* context, const ::seshat::AddSpawnConstraintRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::AddSpawnConstraintResponse>* PrepareAsyncAddSpawnConstraintRaw(::grpc::ClientContext* context, const ::seshat::AddSpawnConstraintRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::RemoveSpawnConstraintResponse>* AsyncRemoveSpawnConstraintRaw(::grpc::ClientContext* context, const ::seshat::RemoveSpawnConstraintRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::RemoveSpawnConstraintResponse>* PrepareAsyncRemoveSpawnConstraintRaw(::grpc::ClientContext* context, const ::seshat::RemoveSpawnConstraintRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnConstraintsResponse>* AsyncGetSpawnConstraintsRaw(::grpc::ClientContext* context, const ::seshat::GetSpawnConstraintsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnConstraintsResponse>* PrepareAsyncGetSpawnConstraintsRaw(::grpc::ClientContext* context, const ::seshat::GetSpawnConstraintsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::ValidateSpawnPositionResponse>* AsyncValidateSpawnPositionRaw(::grpc::ClientContext* context, const ::seshat::ValidateSpawnPositionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::ValidateSpawnPositionResponse>* PrepareAsyncValidateSpawnPositionRaw(::grpc::ClientContext* context, const ::seshat::ValidateSpawnPositionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::AnalyzeSpawnCapacityResponse>* AsyncAnalyzeSpawnCapacityRaw(::grpc::ClientContext* context, const ::seshat::AnalyzeSpawnCapacityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::AnalyzeSpawnCapacityResponse>* PrepareAsyncAnalyzeSpawnCapacityRaw(::grpc::ClientContext* context, const ::seshat::AnalyzeSpawnCapacityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetOptimalSpawnPositionsResponse>* AsyncGetOptimalSpawnPositionsRaw(::grpc::ClientContext* context, const ::seshat::GetOptimalSpawnPositionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetOptimalSpawnPositionsResponse>* PrepareAsyncGetOptimalSpawnPositionsRaw(::grpc::ClientContext* context, const ::seshat::GetOptimalSpawnPositionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::RecommendRoomSplitResponse>* AsyncRecommendRoomSplitRaw(::grpc::ClientContext* context, const ::seshat::RecommendRoomSplitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::RecommendRoomSplitResponse>* PrepareAsyncRecommendRoomSplitRaw(::grpc::ClientContext* context, const ::seshat::RecommendRoomSplitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnHistoryResponse>* AsyncGetSpawnHistoryRaw(::grpc::ClientContext* context, const ::seshat::GetSpawnHistoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetSpawnHistoryResponse>* PrepareAsyncGetSpawnHistoryRaw(::grpc::ClientContext* context, const ::seshat::GetSpawnHistoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetActiveSpawnsResponse>* AsyncGetActiveSpawnsRaw(::grpc::ClientContext* context, const ::seshat::GetActiveSpawnsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetActiveSpawnsResponse>* PrepareAsyncGetActiveSpawnsRaw(::grpc::ClientContext* context, const ::seshat::GetActiveSpawnsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::DespawnEntityResponse>* AsyncDespawnEntityRaw(::grpc::ClientContext* context, const ::seshat::DespawnEntityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::DespawnEntityResponse>* PrepareAsyncDespawnEntityRaw(::grpc::ClientContext* context, const ::seshat::DespawnEntityRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CreateSpawnEngine_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSpawnEngine_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteSpawnEngine_;
    const ::grpc::internal::RpcMethod rpcmethod_SpawnEntity_;
    const ::grpc::internal::RpcMethod rpcmethod_SpawnMultipleEntities_;
    const ::grpc::internal::RpcMethod rpcmethod_SpawnFromPattern_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSpawnPatterns_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateSpawnPattern_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateSpawnPattern_;
    const ::grpc::internal::RpcMethod rpcmethod_AddSpawnConstraint_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveSpawnConstraint_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSpawnConstraints_;
    const ::grpc::internal::RpcMethod rpcmethod_ValidateSpawnPosition_;
    const ::grpc::internal::RpcMethod rpcmethod_AnalyzeSpawnCapacity_;
    const ::grpc::internal::RpcMethod rpcmethod_GetOptimalSpawnPositions_;
    const ::grpc::internal::RpcMethod rpcmethod_RecommendRoomSplit_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSpawnHistory_;
    const ::grpc::internal::RpcMethod rpcmethod_GetActiveSpawns_;
    const ::grpc::internal::RpcMethod rpcmethod_DespawnEntity_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Spawn engine management
    virtual ::grpc::Status CreateSpawnEngine(::grpc::ServerContext* context, const ::seshat::CreateSpawnEngineRequest* request, ::seshat::CreateSpawnEngineResponse* response);
    virtual ::grpc::Status GetSpawnEngine(::grpc::ServerContext* context, const ::seshat::GetSpawnEngineRequest* request, ::seshat::GetSpawnEngineResponse* response);
    virtual ::grpc::Status DeleteSpawnEngine(::grpc::ServerContext* context, const ::seshat::DeleteSpawnEngineRequest* request, ::seshat::DeleteSpawnEngineResponse* response);
    // Entity spawning
    virtual ::grpc::Status SpawnEntity(::grpc::ServerContext* context, const ::seshat::SpawnEntityRequest* request, ::seshat::SpawnEntityResponse* response);
    virtual ::grpc::Status SpawnMultipleEntities(::grpc::ServerContext* context, const ::seshat::SpawnMultipleEntitiesRequest* request, ::seshat::SpawnMultipleEntitiesResponse* response);
    virtual ::grpc::Status SpawnFromPattern(::grpc::ServerContext* context, const ::seshat::SpawnFromPatternRequest* request, ::seshat::SpawnFromPatternResponse* response);
    // Spawn patterns and configurations
    virtual ::grpc::Status GetSpawnPatterns(::grpc::ServerContext* context, const ::seshat::GetSpawnPatternsRequest* request, ::seshat::GetSpawnPatternsResponse* response);
    virtual ::grpc::Status CreateSpawnPattern(::grpc::ServerContext* context, const ::seshat::CreateSpawnPatternRequest* request, ::seshat::CreateSpawnPatternResponse* response);
    virtual ::grpc::Status UpdateSpawnPattern(::grpc::ServerContext* context, const ::seshat::UpdateSpawnPatternRequest* request, ::seshat::UpdateSpawnPatternResponse* response);
    // Constraint management
    virtual ::grpc::Status AddSpawnConstraint(::grpc::ServerContext* context, const ::seshat::AddSpawnConstraintRequest* request, ::seshat::AddSpawnConstraintResponse* response);
    virtual ::grpc::Status RemoveSpawnConstraint(::grpc::ServerContext* context, const ::seshat::RemoveSpawnConstraintRequest* request, ::seshat::RemoveSpawnConstraintResponse* response);
    virtual ::grpc::Status GetSpawnConstraints(::grpc::ServerContext* context, const ::seshat::GetSpawnConstraintsRequest* request, ::seshat::GetSpawnConstraintsResponse* response);
    virtual ::grpc::Status ValidateSpawnPosition(::grpc::ServerContext* context, const ::seshat::ValidateSpawnPositionRequest* request, ::seshat::ValidateSpawnPositionResponse* response);
    // Capacity analysis and optimization
    virtual ::grpc::Status AnalyzeSpawnCapacity(::grpc::ServerContext* context, const ::seshat::AnalyzeSpawnCapacityRequest* request, ::seshat::AnalyzeSpawnCapacityResponse* response);
    virtual ::grpc::Status GetOptimalSpawnPositions(::grpc::ServerContext* context, const ::seshat::GetOptimalSpawnPositionsRequest* request, ::seshat::GetOptimalSpawnPositionsResponse* response);
    virtual ::grpc::Status RecommendRoomSplit(::grpc::ServerContext* context, const ::seshat::RecommendRoomSplitRequest* request, ::seshat::RecommendRoomSplitResponse* response);
    // Spawn history and tracking
    virtual ::grpc::Status GetSpawnHistory(::grpc::ServerContext* context, const ::seshat::GetSpawnHistoryRequest* request, ::seshat::GetSpawnHistoryResponse* response);
    virtual ::grpc::Status GetActiveSpawns(::grpc::ServerContext* context, const ::seshat::GetActiveSpawnsRequest* request, ::seshat::GetActiveSpawnsResponse* response);
    virtual ::grpc::Status DespawnEntity(::grpc::ServerContext* context, const ::seshat::DespawnEntityRequest* request, ::seshat::DespawnEntityResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateSpawnEngine() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CreateSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::CreateSpawnEngineRequest* /*request*/, ::seshat::CreateSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateSpawnEngine(::grpc::ServerContext* context, ::seshat::CreateSpawnEngineRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::CreateSpawnEngineResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSpawnEngine() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnEngineRequest* /*request*/, ::seshat::GetSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSpawnEngine(::grpc::ServerContext* context, ::seshat::GetSpawnEngineRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GetSpawnEngineResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteSpawnEngine() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_DeleteSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::DeleteSpawnEngineRequest* /*request*/, ::seshat::DeleteSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteSpawnEngine(::grpc::ServerContext* context, ::seshat::DeleteSpawnEngineRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::DeleteSpawnEngineResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SpawnEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SpawnEntity() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SpawnEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpawnEntity(::grpc::ServerContext* /*context*/, const ::seshat::SpawnEntityRequest* /*request*/, ::seshat::SpawnEntityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpawnEntity(::grpc::ServerContext* context, ::seshat::SpawnEntityRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::SpawnEntityResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SpawnMultipleEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SpawnMultipleEntities() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_SpawnMultipleEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpawnMultipleEntities(::grpc::ServerContext* /*context*/, const ::seshat::SpawnMultipleEntitiesRequest* /*request*/, ::seshat::SpawnMultipleEntitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpawnMultipleEntities(::grpc::ServerContext* context, ::seshat::SpawnMultipleEntitiesRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::SpawnMultipleEntitiesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SpawnFromPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SpawnFromPattern() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_SpawnFromPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpawnFromPattern(::grpc::ServerContext* /*context*/, const ::seshat::SpawnFromPatternRequest* /*request*/, ::seshat::SpawnFromPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpawnFromPattern(::grpc::ServerContext* context, ::seshat::SpawnFromPatternRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::SpawnFromPatternResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSpawnPatterns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSpawnPatterns() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetSpawnPatterns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnPatterns(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnPatternsRequest* /*request*/, ::seshat::GetSpawnPatternsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSpawnPatterns(::grpc::ServerContext* context, ::seshat::GetSpawnPatternsRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GetSpawnPatternsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateSpawnPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateSpawnPattern() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_CreateSpawnPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpawnPattern(::grpc::ServerContext* /*context*/, const ::seshat::CreateSpawnPatternRequest* /*request*/, ::seshat::CreateSpawnPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateSpawnPattern(::grpc::ServerContext* context, ::seshat::CreateSpawnPatternRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::CreateSpawnPatternResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateSpawnPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateSpawnPattern() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_UpdateSpawnPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateSpawnPattern(::grpc::ServerContext* /*context*/, const ::seshat::UpdateSpawnPatternRequest* /*request*/, ::seshat::UpdateSpawnPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateSpawnPattern(::grpc::ServerContext* context, ::seshat::UpdateSpawnPatternRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::UpdateSpawnPatternResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddSpawnConstraint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddSpawnConstraint() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_AddSpawnConstraint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddSpawnConstraint(::grpc::ServerContext* /*context*/, const ::seshat::AddSpawnConstraintRequest* /*request*/, ::seshat::AddSpawnConstraintResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddSpawnConstraint(::grpc::ServerContext* context, ::seshat::AddSpawnConstraintRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::AddSpawnConstraintResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveSpawnConstraint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemoveSpawnConstraint() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_RemoveSpawnConstraint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveSpawnConstraint(::grpc::ServerContext* /*context*/, const ::seshat::RemoveSpawnConstraintRequest* /*request*/, ::seshat::RemoveSpawnConstraintResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveSpawnConstraint(::grpc::ServerContext* context, ::seshat::RemoveSpawnConstraintRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::RemoveSpawnConstraintResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSpawnConstraints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSpawnConstraints() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetSpawnConstraints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnConstraints(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnConstraintsRequest* /*request*/, ::seshat::GetSpawnConstraintsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSpawnConstraints(::grpc::ServerContext* context, ::seshat::GetSpawnConstraintsRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GetSpawnConstraintsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ValidateSpawnPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ValidateSpawnPosition() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_ValidateSpawnPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateSpawnPosition(::grpc::ServerContext* /*context*/, const ::seshat::ValidateSpawnPositionRequest* /*request*/, ::seshat::ValidateSpawnPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidateSpawnPosition(::grpc::ServerContext* context, ::seshat::ValidateSpawnPositionRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::ValidateSpawnPositionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AnalyzeSpawnCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AnalyzeSpawnCapacity() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_AnalyzeSpawnCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AnalyzeSpawnCapacity(::grpc::ServerContext* /*context*/, const ::seshat::AnalyzeSpawnCapacityRequest* /*request*/, ::seshat::AnalyzeSpawnCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAnalyzeSpawnCapacity(::grpc::ServerContext* context, ::seshat::AnalyzeSpawnCapacityRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::AnalyzeSpawnCapacityResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetOptimalSpawnPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetOptimalSpawnPositions() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_GetOptimalSpawnPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOptimalSpawnPositions(::grpc::ServerContext* /*context*/, const ::seshat::GetOptimalSpawnPositionsRequest* /*request*/, ::seshat::GetOptimalSpawnPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOptimalSpawnPositions(::grpc::ServerContext* context, ::seshat::GetOptimalSpawnPositionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GetOptimalSpawnPositionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RecommendRoomSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RecommendRoomSplit() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_RecommendRoomSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecommendRoomSplit(::grpc::ServerContext* /*context*/, const ::seshat::RecommendRoomSplitRequest* /*request*/, ::seshat::RecommendRoomSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRecommendRoomSplit(::grpc::ServerContext* context, ::seshat::RecommendRoomSplitRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::RecommendRoomSplitResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSpawnHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSpawnHistory() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_GetSpawnHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnHistory(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnHistoryRequest* /*request*/, ::seshat::GetSpawnHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSpawnHistory(::grpc::ServerContext* context, ::seshat::GetSpawnHistoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GetSpawnHistoryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetActiveSpawns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetActiveSpawns() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_GetActiveSpawns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveSpawns(::grpc::ServerContext* /*context*/, const ::seshat::GetActiveSpawnsRequest* /*request*/, ::seshat::GetActiveSpawnsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActiveSpawns(::grpc::ServerContext* context, ::seshat::GetActiveSpawnsRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GetActiveSpawnsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DespawnEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DespawnEntity() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_DespawnEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DespawnEntity(::grpc::ServerContext* /*context*/, const ::seshat::DespawnEntityRequest* /*request*/, ::seshat::DespawnEntityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDespawnEntity(::grpc::ServerContext* context, ::seshat::DespawnEntityRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::DespawnEntityResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CreateSpawnEngine<WithAsyncMethod_GetSpawnEngine<WithAsyncMethod_DeleteSpawnEngine<WithAsyncMethod_SpawnEntity<WithAsyncMethod_SpawnMultipleEntities<WithAsyncMethod_SpawnFromPattern<WithAsyncMethod_GetSpawnPatterns<WithAsyncMethod_CreateSpawnPattern<WithAsyncMethod_UpdateSpawnPattern<WithAsyncMethod_AddSpawnConstraint<WithAsyncMethod_RemoveSpawnConstraint<WithAsyncMethod_GetSpawnConstraints<WithAsyncMethod_ValidateSpawnPosition<WithAsyncMethod_AnalyzeSpawnCapacity<WithAsyncMethod_GetOptimalSpawnPositions<WithAsyncMethod_RecommendRoomSplit<WithAsyncMethod_GetSpawnHistory<WithAsyncMethod_GetActiveSpawns<WithAsyncMethod_DespawnEntity<Service > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_CreateSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateSpawnEngine() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::CreateSpawnEngineRequest, ::seshat::CreateSpawnEngineResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::CreateSpawnEngineRequest* request, ::seshat::CreateSpawnEngineResponse* response) { return this->CreateSpawnEngine(context, request, response); }));}
    void SetMessageAllocatorFor_CreateSpawnEngine(
        ::grpc::MessageAllocator< ::seshat::CreateSpawnEngineRequest, ::seshat::CreateSpawnEngineResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::CreateSpawnEngineRequest, ::seshat::CreateSpawnEngineResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::CreateSpawnEngineRequest* /*request*/, ::seshat::CreateSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateSpawnEngine(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::CreateSpawnEngineRequest* /*request*/, ::seshat::CreateSpawnEngineResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSpawnEngine() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GetSpawnEngineRequest, ::seshat::GetSpawnEngineResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GetSpawnEngineRequest* request, ::seshat::GetSpawnEngineResponse* response) { return this->GetSpawnEngine(context, request, response); }));}
    void SetMessageAllocatorFor_GetSpawnEngine(
        ::grpc::MessageAllocator< ::seshat::GetSpawnEngineRequest, ::seshat::GetSpawnEngineResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GetSpawnEngineRequest, ::seshat::GetSpawnEngineResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnEngineRequest* /*request*/, ::seshat::GetSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSpawnEngine(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GetSpawnEngineRequest* /*request*/, ::seshat::GetSpawnEngineResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DeleteSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DeleteSpawnEngine() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::DeleteSpawnEngineRequest, ::seshat::DeleteSpawnEngineResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::DeleteSpawnEngineRequest* request, ::seshat::DeleteSpawnEngineResponse* response) { return this->DeleteSpawnEngine(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteSpawnEngine(
        ::grpc::MessageAllocator< ::seshat::DeleteSpawnEngineRequest, ::seshat::DeleteSpawnEngineResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::DeleteSpawnEngineRequest, ::seshat::DeleteSpawnEngineResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DeleteSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::DeleteSpawnEngineRequest* /*request*/, ::seshat::DeleteSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteSpawnEngine(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::DeleteSpawnEngineRequest* /*request*/, ::seshat::DeleteSpawnEngineResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SpawnEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SpawnEntity() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::SpawnEntityRequest, ::seshat::SpawnEntityResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::SpawnEntityRequest* request, ::seshat::SpawnEntityResponse* response) { return this->SpawnEntity(context, request, response); }));}
    void SetMessageAllocatorFor_SpawnEntity(
        ::grpc::MessageAllocator< ::seshat::SpawnEntityRequest, ::seshat::SpawnEntityResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::SpawnEntityRequest, ::seshat::SpawnEntityResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SpawnEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpawnEntity(::grpc::ServerContext* /*context*/, const ::seshat::SpawnEntityRequest* /*request*/, ::seshat::SpawnEntityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SpawnEntity(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::SpawnEntityRequest* /*request*/, ::seshat::SpawnEntityResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SpawnMultipleEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SpawnMultipleEntities() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::SpawnMultipleEntitiesRequest, ::seshat::SpawnMultipleEntitiesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::SpawnMultipleEntitiesRequest* request, ::seshat::SpawnMultipleEntitiesResponse* response) { return this->SpawnMultipleEntities(context, request, response); }));}
    void SetMessageAllocatorFor_SpawnMultipleEntities(
        ::grpc::MessageAllocator< ::seshat::SpawnMultipleEntitiesRequest, ::seshat::SpawnMultipleEntitiesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::SpawnMultipleEntitiesRequest, ::seshat::SpawnMultipleEntitiesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SpawnMultipleEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpawnMultipleEntities(::grpc::ServerContext* /*context*/, const ::seshat::SpawnMultipleEntitiesRequest* /*request*/, ::seshat::SpawnMultipleEntitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SpawnMultipleEntities(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::SpawnMultipleEntitiesRequest* /*request*/, ::seshat::SpawnMultipleEntitiesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SpawnFromPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SpawnFromPattern() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::SpawnFromPatternRequest, ::seshat::SpawnFromPatternResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::SpawnFromPatternRequest* request, ::seshat::SpawnFromPatternResponse* response) { return this->SpawnFromPattern(context, request, response); }));}
    void SetMessageAllocatorFor_SpawnFromPattern(
        ::grpc::MessageAllocator< ::seshat::SpawnFromPatternRequest, ::seshat::SpawnFromPatternResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::SpawnFromPatternRequest, ::seshat::SpawnFromPatternResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SpawnFromPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpawnFromPattern(::grpc::ServerContext* /*context*/, const ::seshat::SpawnFromPatternRequest* /*request*/, ::seshat::SpawnFromPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SpawnFromPattern(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::SpawnFromPatternRequest* /*request*/, ::seshat::SpawnFromPatternResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSpawnPatterns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSpawnPatterns() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GetSpawnPatternsRequest, ::seshat::GetSpawnPatternsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GetSpawnPatternsRequest* request, ::seshat::GetSpawnPatternsResponse* response) { return this->GetSpawnPatterns(context, request, response); }));}
    void SetMessageAllocatorFor_GetSpawnPatterns(
        ::grpc::MessageAllocator< ::seshat::GetSpawnPatternsRequest, ::seshat::GetSpawnPatternsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GetSpawnPatternsRequest, ::seshat::GetSpawnPatternsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSpawnPatterns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnPatterns(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnPatternsRequest* /*request*/, ::seshat::GetSpawnPatternsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSpawnPatterns(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GetSpawnPatternsRequest* /*request*/, ::seshat::GetSpawnPatternsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateSpawnPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateSpawnPattern() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::CreateSpawnPatternRequest, ::seshat::CreateSpawnPatternResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::CreateSpawnPatternRequest* request, ::seshat::CreateSpawnPatternResponse* response) { return this->CreateSpawnPattern(context, request, response); }));}
    void SetMessageAllocatorFor_CreateSpawnPattern(
        ::grpc::MessageAllocator< ::seshat::CreateSpawnPatternRequest, ::seshat::CreateSpawnPatternResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::CreateSpawnPatternRequest, ::seshat::CreateSpawnPatternResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateSpawnPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpawnPattern(::grpc::ServerContext* /*context*/, const ::seshat::CreateSpawnPatternRequest* /*request*/, ::seshat::CreateSpawnPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateSpawnPattern(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::CreateSpawnPatternRequest* /*request*/, ::seshat::CreateSpawnPatternResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateSpawnPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateSpawnPattern() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::UpdateSpawnPatternRequest, ::seshat::UpdateSpawnPatternResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::UpdateSpawnPatternRequest* request, ::seshat::UpdateSpawnPatternResponse* response) { return this->UpdateSpawnPattern(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateSpawnPattern(
        ::grpc::MessageAllocator< ::seshat::UpdateSpawnPatternRequest, ::seshat::UpdateSpawnPatternResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::UpdateSpawnPatternRequest, ::seshat::UpdateSpawnPatternResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateSpawnPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateSpawnPattern(::grpc::ServerContext* /*context*/, const ::seshat::UpdateSpawnPatternRequest* /*request*/, ::seshat::UpdateSpawnPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateSpawnPattern(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::UpdateSpawnPatternRequest* /*request*/, ::seshat::UpdateSpawnPatternResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AddSpawnConstraint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AddSpawnConstraint() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::AddSpawnConstraintRequest, ::seshat::AddSpawnConstraintResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::AddSpawnConstraintRequest* request, ::seshat::AddSpawnConstraintResponse* response) { return this->AddSpawnConstraint(context, request, response); }));}
    void SetMessageAllocatorFor_AddSpawnConstraint(
        ::grpc::MessageAllocator< ::seshat::AddSpawnConstraintRequest, ::seshat::AddSpawnConstraintResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::AddSpawnConstraintRequest, ::seshat::AddSpawnConstraintResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AddSpawnConstraint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddSpawnConstraint(::grpc::ServerContext* /*context*/, const ::seshat::AddSpawnConstraintRequest* /*request*/, ::seshat::AddSpawnConstraintResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddSpawnConstraint(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::AddSpawnConstraintRequest* /*request*/, ::seshat::AddSpawnConstraintResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RemoveSpawnConstraint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RemoveSpawnConstraint() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::RemoveSpawnConstraintRequest, ::seshat::RemoveSpawnConstraintResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::RemoveSpawnConstraintRequest* request, ::seshat::RemoveSpawnConstraintResponse* response) { return this->RemoveSpawnConstraint(context, request, response); }));}
    void SetMessageAllocatorFor_RemoveSpawnConstraint(
        ::grpc::MessageAllocator< ::seshat::RemoveSpawnConstraintRequest, ::seshat::RemoveSpawnConstraintResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::RemoveSpawnConstraintRequest, ::seshat::RemoveSpawnConstraintResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RemoveSpawnConstraint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveSpawnConstraint(::grpc::ServerContext* /*context*/, const ::seshat::RemoveSpawnConstraintRequest* /*request*/, ::seshat::RemoveSpawnConstraintResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemoveSpawnConstraint(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::RemoveSpawnConstraintRequest* /*request*/, ::seshat::RemoveSpawnConstraintResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSpawnConstraints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSpawnConstraints() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GetSpawnConstraintsRequest, ::seshat::GetSpawnConstraintsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GetSpawnConstraintsRequest* request, ::seshat::GetSpawnConstraintsResponse* response) { return this->GetSpawnConstraints(context, request, response); }));}
    void SetMessageAllocatorFor_GetSpawnConstraints(
        ::grpc::MessageAllocator< ::seshat::GetSpawnConstraintsRequest, ::seshat::GetSpawnConstraintsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GetSpawnConstraintsRequest, ::seshat::GetSpawnConstraintsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSpawnConstraints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnConstraints(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnConstraintsRequest* /*request*/, ::seshat::GetSpawnConstraintsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSpawnConstraints(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GetSpawnConstraintsRequest* /*request*/, ::seshat::GetSpawnConstraintsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ValidateSpawnPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ValidateSpawnPosition() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::ValidateSpawnPositionRequest, ::seshat::ValidateSpawnPositionResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::ValidateSpawnPositionRequest* request, ::seshat::ValidateSpawnPositionResponse* response) { return this->ValidateSpawnPosition(context, request, response); }));}
    void SetMessageAllocatorFor_ValidateSpawnPosition(
        ::grpc::MessageAllocator< ::seshat::ValidateSpawnPositionRequest, ::seshat::ValidateSpawnPositionResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::ValidateSpawnPositionRequest, ::seshat::ValidateSpawnPositionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ValidateSpawnPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateSpawnPosition(::grpc::ServerContext* /*context*/, const ::seshat::ValidateSpawnPositionRequest* /*request*/, ::seshat::ValidateSpawnPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ValidateSpawnPosition(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::ValidateSpawnPositionRequest* /*request*/, ::seshat::ValidateSpawnPositionResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AnalyzeSpawnCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AnalyzeSpawnCapacity() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::AnalyzeSpawnCapacityRequest, ::seshat::AnalyzeSpawnCapacityResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::AnalyzeSpawnCapacityRequest* request, ::seshat::AnalyzeSpawnCapacityResponse* response) { return this->AnalyzeSpawnCapacity(context, request, response); }));}
    void SetMessageAllocatorFor_AnalyzeSpawnCapacity(
        ::grpc::MessageAllocator< ::seshat::AnalyzeSpawnCapacityRequest, ::seshat::AnalyzeSpawnCapacityResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::AnalyzeSpawnCapacityRequest, ::seshat::AnalyzeSpawnCapacityResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AnalyzeSpawnCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AnalyzeSpawnCapacity(::grpc::ServerContext* /*context*/, const ::seshat::AnalyzeSpawnCapacityRequest* /*request*/, ::seshat::AnalyzeSpawnCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AnalyzeSpawnCapacity(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::AnalyzeSpawnCapacityRequest* /*request*/, ::seshat::AnalyzeSpawnCapacityResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetOptimalSpawnPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetOptimalSpawnPositions() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GetOptimalSpawnPositionsRequest, ::seshat::GetOptimalSpawnPositionsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GetOptimalSpawnPositionsRequest* request, ::seshat::GetOptimalSpawnPositionsResponse* response) { return this->GetOptimalSpawnPositions(context, request, response); }));}
    void SetMessageAllocatorFor_GetOptimalSpawnPositions(
        ::grpc::MessageAllocator< ::seshat::GetOptimalSpawnPositionsRequest, ::seshat::GetOptimalSpawnPositionsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GetOptimalSpawnPositionsRequest, ::seshat::GetOptimalSpawnPositionsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetOptimalSpawnPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOptimalSpawnPositions(::grpc::ServerContext* /*context*/, const ::seshat::GetOptimalSpawnPositionsRequest* /*request*/, ::seshat::GetOptimalSpawnPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetOptimalSpawnPositions(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GetOptimalSpawnPositionsRequest* /*request*/, ::seshat::GetOptimalSpawnPositionsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RecommendRoomSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RecommendRoomSplit() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::RecommendRoomSplitRequest, ::seshat::RecommendRoomSplitResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::RecommendRoomSplitRequest* request, ::seshat::RecommendRoomSplitResponse* response) { return this->RecommendRoomSplit(context, request, response); }));}
    void SetMessageAllocatorFor_RecommendRoomSplit(
        ::grpc::MessageAllocator< ::seshat::RecommendRoomSplitRequest, ::seshat::RecommendRoomSplitResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::RecommendRoomSplitRequest, ::seshat::RecommendRoomSplitResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RecommendRoomSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecommendRoomSplit(::grpc::ServerContext* /*context*/, const ::seshat::RecommendRoomSplitRequest* /*request*/, ::seshat::RecommendRoomSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RecommendRoomSplit(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::RecommendRoomSplitRequest* /*request*/, ::seshat::RecommendRoomSplitResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSpawnHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSpawnHistory() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GetSpawnHistoryRequest, ::seshat::GetSpawnHistoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GetSpawnHistoryRequest* request, ::seshat::GetSpawnHistoryResponse* response) { return this->GetSpawnHistory(context, request, response); }));}
    void SetMessageAllocatorFor_GetSpawnHistory(
        ::grpc::MessageAllocator< ::seshat::GetSpawnHistoryRequest, ::seshat::GetSpawnHistoryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GetSpawnHistoryRequest, ::seshat::GetSpawnHistoryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSpawnHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnHistory(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnHistoryRequest* /*request*/, ::seshat::GetSpawnHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSpawnHistory(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GetSpawnHistoryRequest* /*request*/, ::seshat::GetSpawnHistoryResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetActiveSpawns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetActiveSpawns() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GetActiveSpawnsRequest, ::seshat::GetActiveSpawnsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GetActiveSpawnsRequest* request, ::seshat::GetActiveSpawnsResponse* response) { return this->GetActiveSpawns(context, request, response); }));}
    void SetMessageAllocatorFor_GetActiveSpawns(
        ::grpc::MessageAllocator< ::seshat::GetActiveSpawnsRequest, ::seshat::GetActiveSpawnsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GetActiveSpawnsRequest, ::seshat::GetActiveSpawnsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetActiveSpawns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveSpawns(::grpc::ServerContext* /*context*/, const ::seshat::GetActiveSpawnsRequest* /*request*/, ::seshat::GetActiveSpawnsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetActiveSpawns(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GetActiveSpawnsRequest* /*request*/, ::seshat::GetActiveSpawnsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DespawnEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DespawnEntity() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::DespawnEntityRequest, ::seshat::DespawnEntityResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::DespawnEntityRequest* request, ::seshat::DespawnEntityResponse* response) { return this->DespawnEntity(context, request, response); }));}
    void SetMessageAllocatorFor_DespawnEntity(
        ::grpc::MessageAllocator< ::seshat::DespawnEntityRequest, ::seshat::DespawnEntityResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::DespawnEntityRequest, ::seshat::DespawnEntityResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DespawnEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DespawnEntity(::grpc::ServerContext* /*context*/, const ::seshat::DespawnEntityRequest* /*request*/, ::seshat::DespawnEntityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DespawnEntity(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::DespawnEntityRequest* /*request*/, ::seshat::DespawnEntityResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_CreateSpawnEngine<WithCallbackMethod_GetSpawnEngine<WithCallbackMethod_DeleteSpawnEngine<WithCallbackMethod_SpawnEntity<WithCallbackMethod_SpawnMultipleEntities<WithCallbackMethod_SpawnFromPattern<WithCallbackMethod_GetSpawnPatterns<WithCallbackMethod_CreateSpawnPattern<WithCallbackMethod_UpdateSpawnPattern<WithCallbackMethod_AddSpawnConstraint<WithCallbackMethod_RemoveSpawnConstraint<WithCallbackMethod_GetSpawnConstraints<WithCallbackMethod_ValidateSpawnPosition<WithCallbackMethod_AnalyzeSpawnCapacity<WithCallbackMethod_GetOptimalSpawnPositions<WithCallbackMethod_RecommendRoomSplit<WithCallbackMethod_GetSpawnHistory<WithCallbackMethod_GetActiveSpawns<WithCallbackMethod_DespawnEntity<Service > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CreateSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateSpawnEngine() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CreateSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::CreateSpawnEngineRequest* /*request*/, ::seshat::CreateSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSpawnEngine() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnEngineRequest* /*request*/, ::seshat::GetSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteSpawnEngine() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_DeleteSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::DeleteSpawnEngineRequest* /*request*/, ::seshat::DeleteSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SpawnEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SpawnEntity() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SpawnEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpawnEntity(::grpc::ServerContext* /*context*/, const ::seshat::SpawnEntityRequest* /*request*/, ::seshat::SpawnEntityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SpawnMultipleEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SpawnMultipleEntities() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_SpawnMultipleEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpawnMultipleEntities(::grpc::ServerContext* /*context*/, const ::seshat::SpawnMultipleEntitiesRequest* /*request*/, ::seshat::SpawnMultipleEntitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SpawnFromPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SpawnFromPattern() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SpawnFromPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpawnFromPattern(::grpc::ServerContext* /*context*/, const ::seshat::SpawnFromPatternRequest* /*request*/, ::seshat::SpawnFromPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSpawnPatterns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSpawnPatterns() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetSpawnPatterns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnPatterns(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnPatternsRequest* /*request*/, ::seshat::GetSpawnPatternsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateSpawnPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateSpawnPattern() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_CreateSpawnPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpawnPattern(::grpc::ServerContext* /*context*/, const ::seshat::CreateSpawnPatternRequest* /*request*/, ::seshat::CreateSpawnPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateSpawnPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateSpawnPattern() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_UpdateSpawnPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateSpawnPattern(::grpc::ServerContext* /*context*/, const ::seshat::UpdateSpawnPatternRequest* /*request*/, ::seshat::UpdateSpawnPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddSpawnConstraint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddSpawnConstraint() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_AddSpawnConstraint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddSpawnConstraint(::grpc::ServerContext* /*context*/, const ::seshat::AddSpawnConstraintRequest* /*request*/, ::seshat::AddSpawnConstraintResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveSpawnConstraint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemoveSpawnConstraint() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_RemoveSpawnConstraint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveSpawnConstraint(::grpc::ServerContext* /*context*/, const ::seshat::RemoveSpawnConstraintRequest* /*request*/, ::seshat::RemoveSpawnConstraintResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSpawnConstraints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSpawnConstraints() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetSpawnConstraints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnConstraints(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnConstraintsRequest* /*request*/, ::seshat::GetSpawnConstraintsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ValidateSpawnPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ValidateSpawnPosition() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_ValidateSpawnPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateSpawnPosition(::grpc::ServerContext* /*context*/, const ::seshat::ValidateSpawnPositionRequest* /*request*/, ::seshat::ValidateSpawnPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AnalyzeSpawnCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AnalyzeSpawnCapacity() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_AnalyzeSpawnCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AnalyzeSpawnCapacity(::grpc::ServerContext* /*context*/, const ::seshat::AnalyzeSpawnCapacityRequest* /*request*/, ::seshat::AnalyzeSpawnCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetOptimalSpawnPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetOptimalSpawnPositions() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_GetOptimalSpawnPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOptimalSpawnPositions(::grpc::ServerContext* /*context*/, const ::seshat::GetOptimalSpawnPositionsRequest* /*request*/, ::seshat::GetOptimalSpawnPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RecommendRoomSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RecommendRoomSplit() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_RecommendRoomSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecommendRoomSplit(::grpc::ServerContext* /*context*/, const ::seshat::RecommendRoomSplitRequest* /*request*/, ::seshat::RecommendRoomSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSpawnHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSpawnHistory() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_GetSpawnHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnHistory(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnHistoryRequest* /*request*/, ::seshat::GetSpawnHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetActiveSpawns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetActiveSpawns() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_GetActiveSpawns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveSpawns(::grpc::ServerContext* /*context*/, const ::seshat::GetActiveSpawnsRequest* /*request*/, ::seshat::GetActiveSpawnsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DespawnEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DespawnEntity() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_DespawnEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DespawnEntity(::grpc::ServerContext* /*context*/, const ::seshat::DespawnEntityRequest* /*request*/, ::seshat::DespawnEntityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateSpawnEngine() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CreateSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::CreateSpawnEngineRequest* /*request*/, ::seshat::CreateSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateSpawnEngine(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSpawnEngine() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnEngineRequest* /*request*/, ::seshat::GetSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSpawnEngine(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteSpawnEngine() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_DeleteSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::DeleteSpawnEngineRequest* /*request*/, ::seshat::DeleteSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteSpawnEngine(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SpawnEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SpawnEntity() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_SpawnEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpawnEntity(::grpc::ServerContext* /*context*/, const ::seshat::SpawnEntityRequest* /*request*/, ::seshat::SpawnEntityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpawnEntity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SpawnMultipleEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SpawnMultipleEntities() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_SpawnMultipleEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpawnMultipleEntities(::grpc::ServerContext* /*context*/, const ::seshat::SpawnMultipleEntitiesRequest* /*request*/, ::seshat::SpawnMultipleEntitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpawnMultipleEntities(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SpawnFromPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SpawnFromPattern() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_SpawnFromPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpawnFromPattern(::grpc::ServerContext* /*context*/, const ::seshat::SpawnFromPatternRequest* /*request*/, ::seshat::SpawnFromPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSpawnFromPattern(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSpawnPatterns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSpawnPatterns() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetSpawnPatterns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnPatterns(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnPatternsRequest* /*request*/, ::seshat::GetSpawnPatternsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSpawnPatterns(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateSpawnPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateSpawnPattern() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_CreateSpawnPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpawnPattern(::grpc::ServerContext* /*context*/, const ::seshat::CreateSpawnPatternRequest* /*request*/, ::seshat::CreateSpawnPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateSpawnPattern(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateSpawnPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateSpawnPattern() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_UpdateSpawnPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateSpawnPattern(::grpc::ServerContext* /*context*/, const ::seshat::UpdateSpawnPatternRequest* /*request*/, ::seshat::UpdateSpawnPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateSpawnPattern(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddSpawnConstraint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddSpawnConstraint() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_AddSpawnConstraint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddSpawnConstraint(::grpc::ServerContext* /*context*/, const ::seshat::AddSpawnConstraintRequest* /*request*/, ::seshat::AddSpawnConstraintResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddSpawnConstraint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoveSpawnConstraint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemoveSpawnConstraint() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_RemoveSpawnConstraint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveSpawnConstraint(::grpc::ServerContext* /*context*/, const ::seshat::RemoveSpawnConstraintRequest* /*request*/, ::seshat::RemoveSpawnConstraintResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveSpawnConstraint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSpawnConstraints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSpawnConstraints() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetSpawnConstraints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnConstraints(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnConstraintsRequest* /*request*/, ::seshat::GetSpawnConstraintsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSpawnConstraints(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ValidateSpawnPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ValidateSpawnPosition() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_ValidateSpawnPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateSpawnPosition(::grpc::ServerContext* /*context*/, const ::seshat::ValidateSpawnPositionRequest* /*request*/, ::seshat::ValidateSpawnPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidateSpawnPosition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AnalyzeSpawnCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AnalyzeSpawnCapacity() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_AnalyzeSpawnCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AnalyzeSpawnCapacity(::grpc::ServerContext* /*context*/, const ::seshat::AnalyzeSpawnCapacityRequest* /*request*/, ::seshat::AnalyzeSpawnCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAnalyzeSpawnCapacity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetOptimalSpawnPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetOptimalSpawnPositions() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_GetOptimalSpawnPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOptimalSpawnPositions(::grpc::ServerContext* /*context*/, const ::seshat::GetOptimalSpawnPositionsRequest* /*request*/, ::seshat::GetOptimalSpawnPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOptimalSpawnPositions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RecommendRoomSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RecommendRoomSplit() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_RecommendRoomSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecommendRoomSplit(::grpc::ServerContext* /*context*/, const ::seshat::RecommendRoomSplitRequest* /*request*/, ::seshat::RecommendRoomSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRecommendRoomSplit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSpawnHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSpawnHistory() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_GetSpawnHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnHistory(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnHistoryRequest* /*request*/, ::seshat::GetSpawnHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSpawnHistory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetActiveSpawns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetActiveSpawns() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_GetActiveSpawns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveSpawns(::grpc::ServerContext* /*context*/, const ::seshat::GetActiveSpawnsRequest* /*request*/, ::seshat::GetActiveSpawnsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetActiveSpawns(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DespawnEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DespawnEntity() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_DespawnEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DespawnEntity(::grpc::ServerContext* /*context*/, const ::seshat::DespawnEntityRequest* /*request*/, ::seshat::DespawnEntityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDespawnEntity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateSpawnEngine() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateSpawnEngine(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::CreateSpawnEngineRequest* /*request*/, ::seshat::CreateSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateSpawnEngine(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSpawnEngine() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSpawnEngine(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnEngineRequest* /*request*/, ::seshat::GetSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSpawnEngine(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DeleteSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DeleteSpawnEngine() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteSpawnEngine(context, request, response); }));
    }
    ~WithRawCallbackMethod_DeleteSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::DeleteSpawnEngineRequest* /*request*/, ::seshat::DeleteSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteSpawnEngine(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SpawnEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SpawnEntity() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SpawnEntity(context, request, response); }));
    }
    ~WithRawCallbackMethod_SpawnEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpawnEntity(::grpc::ServerContext* /*context*/, const ::seshat::SpawnEntityRequest* /*request*/, ::seshat::SpawnEntityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SpawnEntity(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SpawnMultipleEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SpawnMultipleEntities() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SpawnMultipleEntities(context, request, response); }));
    }
    ~WithRawCallbackMethod_SpawnMultipleEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpawnMultipleEntities(::grpc::ServerContext* /*context*/, const ::seshat::SpawnMultipleEntitiesRequest* /*request*/, ::seshat::SpawnMultipleEntitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SpawnMultipleEntities(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SpawnFromPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SpawnFromPattern() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SpawnFromPattern(context, request, response); }));
    }
    ~WithRawCallbackMethod_SpawnFromPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SpawnFromPattern(::grpc::ServerContext* /*context*/, const ::seshat::SpawnFromPatternRequest* /*request*/, ::seshat::SpawnFromPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SpawnFromPattern(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSpawnPatterns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSpawnPatterns() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSpawnPatterns(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSpawnPatterns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnPatterns(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnPatternsRequest* /*request*/, ::seshat::GetSpawnPatternsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSpawnPatterns(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateSpawnPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateSpawnPattern() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateSpawnPattern(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateSpawnPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSpawnPattern(::grpc::ServerContext* /*context*/, const ::seshat::CreateSpawnPatternRequest* /*request*/, ::seshat::CreateSpawnPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateSpawnPattern(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateSpawnPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateSpawnPattern() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateSpawnPattern(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateSpawnPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateSpawnPattern(::grpc::ServerContext* /*context*/, const ::seshat::UpdateSpawnPatternRequest* /*request*/, ::seshat::UpdateSpawnPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateSpawnPattern(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AddSpawnConstraint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AddSpawnConstraint() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddSpawnConstraint(context, request, response); }));
    }
    ~WithRawCallbackMethod_AddSpawnConstraint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddSpawnConstraint(::grpc::ServerContext* /*context*/, const ::seshat::AddSpawnConstraintRequest* /*request*/, ::seshat::AddSpawnConstraintResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddSpawnConstraint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RemoveSpawnConstraint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RemoveSpawnConstraint() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RemoveSpawnConstraint(context, request, response); }));
    }
    ~WithRawCallbackMethod_RemoveSpawnConstraint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveSpawnConstraint(::grpc::ServerContext* /*context*/, const ::seshat::RemoveSpawnConstraintRequest* /*request*/, ::seshat::RemoveSpawnConstraintResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RemoveSpawnConstraint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSpawnConstraints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSpawnConstraints() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSpawnConstraints(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSpawnConstraints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnConstraints(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnConstraintsRequest* /*request*/, ::seshat::GetSpawnConstraintsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSpawnConstraints(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ValidateSpawnPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ValidateSpawnPosition() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ValidateSpawnPosition(context, request, response); }));
    }
    ~WithRawCallbackMethod_ValidateSpawnPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateSpawnPosition(::grpc::ServerContext* /*context*/, const ::seshat::ValidateSpawnPositionRequest* /*request*/, ::seshat::ValidateSpawnPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ValidateSpawnPosition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AnalyzeSpawnCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AnalyzeSpawnCapacity() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AnalyzeSpawnCapacity(context, request, response); }));
    }
    ~WithRawCallbackMethod_AnalyzeSpawnCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AnalyzeSpawnCapacity(::grpc::ServerContext* /*context*/, const ::seshat::AnalyzeSpawnCapacityRequest* /*request*/, ::seshat::AnalyzeSpawnCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AnalyzeSpawnCapacity(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetOptimalSpawnPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetOptimalSpawnPositions() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetOptimalSpawnPositions(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetOptimalSpawnPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOptimalSpawnPositions(::grpc::ServerContext* /*context*/, const ::seshat::GetOptimalSpawnPositionsRequest* /*request*/, ::seshat::GetOptimalSpawnPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetOptimalSpawnPositions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RecommendRoomSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RecommendRoomSplit() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RecommendRoomSplit(context, request, response); }));
    }
    ~WithRawCallbackMethod_RecommendRoomSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RecommendRoomSplit(::grpc::ServerContext* /*context*/, const ::seshat::RecommendRoomSplitRequest* /*request*/, ::seshat::RecommendRoomSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RecommendRoomSplit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSpawnHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSpawnHistory() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSpawnHistory(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSpawnHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSpawnHistory(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnHistoryRequest* /*request*/, ::seshat::GetSpawnHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSpawnHistory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetActiveSpawns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetActiveSpawns() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetActiveSpawns(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetActiveSpawns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetActiveSpawns(::grpc::ServerContext* /*context*/, const ::seshat::GetActiveSpawnsRequest* /*request*/, ::seshat::GetActiveSpawnsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetActiveSpawns(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DespawnEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DespawnEntity() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DespawnEntity(context, request, response); }));
    }
    ~WithRawCallbackMethod_DespawnEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DespawnEntity(::grpc::ServerContext* /*context*/, const ::seshat::DespawnEntityRequest* /*request*/, ::seshat::DespawnEntityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DespawnEntity(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateSpawnEngine() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::CreateSpawnEngineRequest, ::seshat::CreateSpawnEngineResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::CreateSpawnEngineRequest, ::seshat::CreateSpawnEngineResponse>* streamer) {
                       return this->StreamedCreateSpawnEngine(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::CreateSpawnEngineRequest* /*request*/, ::seshat::CreateSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateSpawnEngine(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::CreateSpawnEngineRequest,::seshat::CreateSpawnEngineResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSpawnEngine() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GetSpawnEngineRequest, ::seshat::GetSpawnEngineResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GetSpawnEngineRequest, ::seshat::GetSpawnEngineResponse>* streamer) {
                       return this->StreamedGetSpawnEngine(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnEngineRequest* /*request*/, ::seshat::GetSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSpawnEngine(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GetSpawnEngineRequest,::seshat::GetSpawnEngineResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteSpawnEngine : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteSpawnEngine() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::DeleteSpawnEngineRequest, ::seshat::DeleteSpawnEngineResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::DeleteSpawnEngineRequest, ::seshat::DeleteSpawnEngineResponse>* streamer) {
                       return this->StreamedDeleteSpawnEngine(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteSpawnEngine() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteSpawnEngine(::grpc::ServerContext* /*context*/, const ::seshat::DeleteSpawnEngineRequest* /*request*/, ::seshat::DeleteSpawnEngineResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteSpawnEngine(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::DeleteSpawnEngineRequest,::seshat::DeleteSpawnEngineResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SpawnEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SpawnEntity() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::SpawnEntityRequest, ::seshat::SpawnEntityResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::SpawnEntityRequest, ::seshat::SpawnEntityResponse>* streamer) {
                       return this->StreamedSpawnEntity(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SpawnEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SpawnEntity(::grpc::ServerContext* /*context*/, const ::seshat::SpawnEntityRequest* /*request*/, ::seshat::SpawnEntityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSpawnEntity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::SpawnEntityRequest,::seshat::SpawnEntityResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SpawnMultipleEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SpawnMultipleEntities() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::SpawnMultipleEntitiesRequest, ::seshat::SpawnMultipleEntitiesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::SpawnMultipleEntitiesRequest, ::seshat::SpawnMultipleEntitiesResponse>* streamer) {
                       return this->StreamedSpawnMultipleEntities(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SpawnMultipleEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SpawnMultipleEntities(::grpc::ServerContext* /*context*/, const ::seshat::SpawnMultipleEntitiesRequest* /*request*/, ::seshat::SpawnMultipleEntitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSpawnMultipleEntities(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::SpawnMultipleEntitiesRequest,::seshat::SpawnMultipleEntitiesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SpawnFromPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SpawnFromPattern() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::SpawnFromPatternRequest, ::seshat::SpawnFromPatternResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::SpawnFromPatternRequest, ::seshat::SpawnFromPatternResponse>* streamer) {
                       return this->StreamedSpawnFromPattern(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SpawnFromPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SpawnFromPattern(::grpc::ServerContext* /*context*/, const ::seshat::SpawnFromPatternRequest* /*request*/, ::seshat::SpawnFromPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSpawnFromPattern(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::SpawnFromPatternRequest,::seshat::SpawnFromPatternResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSpawnPatterns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSpawnPatterns() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GetSpawnPatternsRequest, ::seshat::GetSpawnPatternsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GetSpawnPatternsRequest, ::seshat::GetSpawnPatternsResponse>* streamer) {
                       return this->StreamedGetSpawnPatterns(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSpawnPatterns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSpawnPatterns(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnPatternsRequest* /*request*/, ::seshat::GetSpawnPatternsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSpawnPatterns(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GetSpawnPatternsRequest,::seshat::GetSpawnPatternsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateSpawnPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateSpawnPattern() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::CreateSpawnPatternRequest, ::seshat::CreateSpawnPatternResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::CreateSpawnPatternRequest, ::seshat::CreateSpawnPatternResponse>* streamer) {
                       return this->StreamedCreateSpawnPattern(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateSpawnPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateSpawnPattern(::grpc::ServerContext* /*context*/, const ::seshat::CreateSpawnPatternRequest* /*request*/, ::seshat::CreateSpawnPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateSpawnPattern(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::CreateSpawnPatternRequest,::seshat::CreateSpawnPatternResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateSpawnPattern : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateSpawnPattern() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::UpdateSpawnPatternRequest, ::seshat::UpdateSpawnPatternResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::UpdateSpawnPatternRequest, ::seshat::UpdateSpawnPatternResponse>* streamer) {
                       return this->StreamedUpdateSpawnPattern(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateSpawnPattern() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateSpawnPattern(::grpc::ServerContext* /*context*/, const ::seshat::UpdateSpawnPatternRequest* /*request*/, ::seshat::UpdateSpawnPatternResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateSpawnPattern(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::UpdateSpawnPatternRequest,::seshat::UpdateSpawnPatternResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddSpawnConstraint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddSpawnConstraint() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::AddSpawnConstraintRequest, ::seshat::AddSpawnConstraintResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::AddSpawnConstraintRequest, ::seshat::AddSpawnConstraintResponse>* streamer) {
                       return this->StreamedAddSpawnConstraint(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddSpawnConstraint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddSpawnConstraint(::grpc::ServerContext* /*context*/, const ::seshat::AddSpawnConstraintRequest* /*request*/, ::seshat::AddSpawnConstraintResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddSpawnConstraint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::AddSpawnConstraintRequest,::seshat::AddSpawnConstraintResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveSpawnConstraint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RemoveSpawnConstraint() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::RemoveSpawnConstraintRequest, ::seshat::RemoveSpawnConstraintResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::RemoveSpawnConstraintRequest, ::seshat::RemoveSpawnConstraintResponse>* streamer) {
                       return this->StreamedRemoveSpawnConstraint(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RemoveSpawnConstraint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveSpawnConstraint(::grpc::ServerContext* /*context*/, const ::seshat::RemoveSpawnConstraintRequest* /*request*/, ::seshat::RemoveSpawnConstraintResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveSpawnConstraint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::RemoveSpawnConstraintRequest,::seshat::RemoveSpawnConstraintResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSpawnConstraints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSpawnConstraints() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GetSpawnConstraintsRequest, ::seshat::GetSpawnConstraintsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GetSpawnConstraintsRequest, ::seshat::GetSpawnConstraintsResponse>* streamer) {
                       return this->StreamedGetSpawnConstraints(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSpawnConstraints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSpawnConstraints(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnConstraintsRequest* /*request*/, ::seshat::GetSpawnConstraintsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSpawnConstraints(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GetSpawnConstraintsRequest,::seshat::GetSpawnConstraintsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ValidateSpawnPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ValidateSpawnPosition() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::ValidateSpawnPositionRequest, ::seshat::ValidateSpawnPositionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::ValidateSpawnPositionRequest, ::seshat::ValidateSpawnPositionResponse>* streamer) {
                       return this->StreamedValidateSpawnPosition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ValidateSpawnPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ValidateSpawnPosition(::grpc::ServerContext* /*context*/, const ::seshat::ValidateSpawnPositionRequest* /*request*/, ::seshat::ValidateSpawnPositionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedValidateSpawnPosition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::ValidateSpawnPositionRequest,::seshat::ValidateSpawnPositionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AnalyzeSpawnCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AnalyzeSpawnCapacity() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::AnalyzeSpawnCapacityRequest, ::seshat::AnalyzeSpawnCapacityResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::AnalyzeSpawnCapacityRequest, ::seshat::AnalyzeSpawnCapacityResponse>* streamer) {
                       return this->StreamedAnalyzeSpawnCapacity(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AnalyzeSpawnCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AnalyzeSpawnCapacity(::grpc::ServerContext* /*context*/, const ::seshat::AnalyzeSpawnCapacityRequest* /*request*/, ::seshat::AnalyzeSpawnCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAnalyzeSpawnCapacity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::AnalyzeSpawnCapacityRequest,::seshat::AnalyzeSpawnCapacityResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetOptimalSpawnPositions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetOptimalSpawnPositions() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GetOptimalSpawnPositionsRequest, ::seshat::GetOptimalSpawnPositionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GetOptimalSpawnPositionsRequest, ::seshat::GetOptimalSpawnPositionsResponse>* streamer) {
                       return this->StreamedGetOptimalSpawnPositions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetOptimalSpawnPositions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetOptimalSpawnPositions(::grpc::ServerContext* /*context*/, const ::seshat::GetOptimalSpawnPositionsRequest* /*request*/, ::seshat::GetOptimalSpawnPositionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetOptimalSpawnPositions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GetOptimalSpawnPositionsRequest,::seshat::GetOptimalSpawnPositionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RecommendRoomSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RecommendRoomSplit() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::RecommendRoomSplitRequest, ::seshat::RecommendRoomSplitResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::RecommendRoomSplitRequest, ::seshat::RecommendRoomSplitResponse>* streamer) {
                       return this->StreamedRecommendRoomSplit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RecommendRoomSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RecommendRoomSplit(::grpc::ServerContext* /*context*/, const ::seshat::RecommendRoomSplitRequest* /*request*/, ::seshat::RecommendRoomSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRecommendRoomSplit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::RecommendRoomSplitRequest,::seshat::RecommendRoomSplitResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSpawnHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSpawnHistory() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GetSpawnHistoryRequest, ::seshat::GetSpawnHistoryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GetSpawnHistoryRequest, ::seshat::GetSpawnHistoryResponse>* streamer) {
                       return this->StreamedGetSpawnHistory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSpawnHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSpawnHistory(::grpc::ServerContext* /*context*/, const ::seshat::GetSpawnHistoryRequest* /*request*/, ::seshat::GetSpawnHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSpawnHistory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GetSpawnHistoryRequest,::seshat::GetSpawnHistoryResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetActiveSpawns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetActiveSpawns() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GetActiveSpawnsRequest, ::seshat::GetActiveSpawnsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GetActiveSpawnsRequest, ::seshat::GetActiveSpawnsResponse>* streamer) {
                       return this->StreamedGetActiveSpawns(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetActiveSpawns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetActiveSpawns(::grpc::ServerContext* /*context*/, const ::seshat::GetActiveSpawnsRequest* /*request*/, ::seshat::GetActiveSpawnsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetActiveSpawns(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GetActiveSpawnsRequest,::seshat::GetActiveSpawnsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DespawnEntity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DespawnEntity() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::DespawnEntityRequest, ::seshat::DespawnEntityResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::DespawnEntityRequest, ::seshat::DespawnEntityResponse>* streamer) {
                       return this->StreamedDespawnEntity(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DespawnEntity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DespawnEntity(::grpc::ServerContext* /*context*/, const ::seshat::DespawnEntityRequest* /*request*/, ::seshat::DespawnEntityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDespawnEntity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::DespawnEntityRequest,::seshat::DespawnEntityResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CreateSpawnEngine<WithStreamedUnaryMethod_GetSpawnEngine<WithStreamedUnaryMethod_DeleteSpawnEngine<WithStreamedUnaryMethod_SpawnEntity<WithStreamedUnaryMethod_SpawnMultipleEntities<WithStreamedUnaryMethod_SpawnFromPattern<WithStreamedUnaryMethod_GetSpawnPatterns<WithStreamedUnaryMethod_CreateSpawnPattern<WithStreamedUnaryMethod_UpdateSpawnPattern<WithStreamedUnaryMethod_AddSpawnConstraint<WithStreamedUnaryMethod_RemoveSpawnConstraint<WithStreamedUnaryMethod_GetSpawnConstraints<WithStreamedUnaryMethod_ValidateSpawnPosition<WithStreamedUnaryMethod_AnalyzeSpawnCapacity<WithStreamedUnaryMethod_GetOptimalSpawnPositions<WithStreamedUnaryMethod_RecommendRoomSplit<WithStreamedUnaryMethod_GetSpawnHistory<WithStreamedUnaryMethod_GetActiveSpawns<WithStreamedUnaryMethod_DespawnEntity<Service > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CreateSpawnEngine<WithStreamedUnaryMethod_GetSpawnEngine<WithStreamedUnaryMethod_DeleteSpawnEngine<WithStreamedUnaryMethod_SpawnEntity<WithStreamedUnaryMethod_SpawnMultipleEntities<WithStreamedUnaryMethod_SpawnFromPattern<WithStreamedUnaryMethod_GetSpawnPatterns<WithStreamedUnaryMethod_CreateSpawnPattern<WithStreamedUnaryMethod_UpdateSpawnPattern<WithStreamedUnaryMethod_AddSpawnConstraint<WithStreamedUnaryMethod_RemoveSpawnConstraint<WithStreamedUnaryMethod_GetSpawnConstraints<WithStreamedUnaryMethod_ValidateSpawnPosition<WithStreamedUnaryMethod_AnalyzeSpawnCapacity<WithStreamedUnaryMethod_GetOptimalSpawnPositions<WithStreamedUnaryMethod_RecommendRoomSplit<WithStreamedUnaryMethod_GetSpawnHistory<WithStreamedUnaryMethod_GetActiveSpawns<WithStreamedUnaryMethod_DespawnEntity<Service > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace seshat


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_seshat_2fspawn_2eproto__INCLUDED
