// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: seshat/environments.proto
#ifndef GRPC_seshat_2fenvironments_2eproto__INCLUDED
#define GRPC_seshat_2fenvironments_2eproto__INCLUDED

#include "seshat/environments.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace seshat {

// Environment generation service - exposes all environments toolkit functionality
class EnvironmentService final {
 public:
  static constexpr char const* service_full_name() {
    return "seshat.EnvironmentService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Room generation
    virtual ::grpc::Status GenerateRoom(::grpc::ClientContext* context, const ::seshat::GenerateRoomRequest& request, ::seshat::GenerateRoomResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateRoomResponse>> AsyncGenerateRoom(::grpc::ClientContext* context, const ::seshat::GenerateRoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateRoomResponse>>(AsyncGenerateRoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateRoomResponse>> PrepareAsyncGenerateRoom(::grpc::ClientContext* context, const ::seshat::GenerateRoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateRoomResponse>>(PrepareAsyncGenerateRoomRaw(context, request, cq));
    }
    virtual ::grpc::Status GenerateRoomWithTemplate(::grpc::ClientContext* context, const ::seshat::GenerateRoomTemplateRequest& request, ::seshat::GenerateRoomTemplateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateRoomTemplateResponse>> AsyncGenerateRoomWithTemplate(::grpc::ClientContext* context, const ::seshat::GenerateRoomTemplateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateRoomTemplateResponse>>(AsyncGenerateRoomWithTemplateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateRoomTemplateResponse>> PrepareAsyncGenerateRoomWithTemplate(::grpc::ClientContext* context, const ::seshat::GenerateRoomTemplateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateRoomTemplateResponse>>(PrepareAsyncGenerateRoomWithTemplateRaw(context, request, cq));
    }
    // Wall system
    virtual ::grpc::Status GenerateWalls(::grpc::ClientContext* context, const ::seshat::GenerateWallsRequest& request, ::seshat::GenerateWallsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateWallsResponse>> AsyncGenerateWalls(::grpc::ClientContext* context, const ::seshat::GenerateWallsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateWallsResponse>>(AsyncGenerateWallsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateWallsResponse>> PrepareAsyncGenerateWalls(::grpc::ClientContext* context, const ::seshat::GenerateWallsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateWallsResponse>>(PrepareAsyncGenerateWallsRaw(context, request, cq));
    }
    virtual ::grpc::Status DestroyWall(::grpc::ClientContext* context, const ::seshat::DestroyWallRequest& request, ::seshat::DestroyWallResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DestroyWallResponse>> AsyncDestroyWall(::grpc::ClientContext* context, const ::seshat::DestroyWallRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DestroyWallResponse>>(AsyncDestroyWallRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DestroyWallResponse>> PrepareAsyncDestroyWall(::grpc::ClientContext* context, const ::seshat::DestroyWallRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DestroyWallResponse>>(PrepareAsyncDestroyWallRaw(context, request, cq));
    }
    virtual ::grpc::Status GetWallInfo(::grpc::ClientContext* context, const ::seshat::GetWallInfoRequest& request, ::seshat::GetWallInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetWallInfoResponse>> AsyncGetWallInfo(::grpc::ClientContext* context, const ::seshat::GetWallInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetWallInfoResponse>>(AsyncGetWallInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetWallInfoResponse>> PrepareAsyncGetWallInfo(::grpc::ClientContext* context, const ::seshat::GetWallInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetWallInfoResponse>>(PrepareAsyncGetWallInfoRaw(context, request, cq));
    }
    // Environment themes and materials
    virtual ::grpc::Status GetThemes(::grpc::ClientContext* context, const ::seshat::GetThemesRequest& request, ::seshat::GetThemesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetThemesResponse>> AsyncGetThemes(::grpc::ClientContext* context, const ::seshat::GetThemesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetThemesResponse>>(AsyncGetThemesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetThemesResponse>> PrepareAsyncGetThemes(::grpc::ClientContext* context, const ::seshat::GetThemesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetThemesResponse>>(PrepareAsyncGetThemesRaw(context, request, cq));
    }
    virtual ::grpc::Status ApplyTheme(::grpc::ClientContext* context, const ::seshat::ApplyThemeRequest& request, ::seshat::ApplyThemeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ApplyThemeResponse>> AsyncApplyTheme(::grpc::ClientContext* context, const ::seshat::ApplyThemeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ApplyThemeResponse>>(AsyncApplyThemeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ApplyThemeResponse>> PrepareAsyncApplyTheme(::grpc::ClientContext* context, const ::seshat::ApplyThemeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ApplyThemeResponse>>(PrepareAsyncApplyThemeRaw(context, request, cq));
    }
    // Shape templates
    virtual ::grpc::Status GetShapeTemplates(::grpc::ClientContext* context, const ::seshat::GetShapeTemplatesRequest& request, ::seshat::GetShapeTemplatesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetShapeTemplatesResponse>> AsyncGetShapeTemplates(::grpc::ClientContext* context, const ::seshat::GetShapeTemplatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetShapeTemplatesResponse>>(AsyncGetShapeTemplatesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetShapeTemplatesResponse>> PrepareAsyncGetShapeTemplates(::grpc::ClientContext* context, const ::seshat::GetShapeTemplatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetShapeTemplatesResponse>>(PrepareAsyncGetShapeTemplatesRaw(context, request, cq));
    }
    virtual ::grpc::Status CreateCustomShape(::grpc::ClientContext* context, const ::seshat::CreateCustomShapeRequest& request, ::seshat::CreateCustomShapeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateCustomShapeResponse>> AsyncCreateCustomShape(::grpc::ClientContext* context, const ::seshat::CreateCustomShapeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateCustomShapeResponse>>(AsyncCreateCustomShapeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateCustomShapeResponse>> PrepareAsyncCreateCustomShape(::grpc::ClientContext* context, const ::seshat::CreateCustomShapeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateCustomShapeResponse>>(PrepareAsyncCreateCustomShapeRaw(context, request, cq));
    }
    // Capacity analysis
    virtual ::grpc::Status AnalyzeCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeCapacityRequest& request, ::seshat::AnalyzeCapacityResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AnalyzeCapacityResponse>> AsyncAnalyzeCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeCapacityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AnalyzeCapacityResponse>>(AsyncAnalyzeCapacityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AnalyzeCapacityResponse>> PrepareAsyncAnalyzeCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeCapacityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AnalyzeCapacityResponse>>(PrepareAsyncAnalyzeCapacityRaw(context, request, cq));
    }
    virtual ::grpc::Status GetOptimalSize(::grpc::ClientContext* context, const ::seshat::GetOptimalSizeRequest& request, ::seshat::GetOptimalSizeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetOptimalSizeResponse>> AsyncGetOptimalSize(::grpc::ClientContext* context, const ::seshat::GetOptimalSizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetOptimalSizeResponse>>(AsyncGetOptimalSizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetOptimalSizeResponse>> PrepareAsyncGetOptimalSize(::grpc::ClientContext* context, const ::seshat::GetOptimalSizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetOptimalSizeResponse>>(PrepareAsyncGetOptimalSizeRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Room generation
      virtual void GenerateRoom(::grpc::ClientContext* context, const ::seshat::GenerateRoomRequest* request, ::seshat::GenerateRoomResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GenerateRoom(::grpc::ClientContext* context, const ::seshat::GenerateRoomRequest* request, ::seshat::GenerateRoomResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GenerateRoomWithTemplate(::grpc::ClientContext* context, const ::seshat::GenerateRoomTemplateRequest* request, ::seshat::GenerateRoomTemplateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GenerateRoomWithTemplate(::grpc::ClientContext* context, const ::seshat::GenerateRoomTemplateRequest* request, ::seshat::GenerateRoomTemplateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Wall system
      virtual void GenerateWalls(::grpc::ClientContext* context, const ::seshat::GenerateWallsRequest* request, ::seshat::GenerateWallsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GenerateWalls(::grpc::ClientContext* context, const ::seshat::GenerateWallsRequest* request, ::seshat::GenerateWallsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DestroyWall(::grpc::ClientContext* context, const ::seshat::DestroyWallRequest* request, ::seshat::DestroyWallResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DestroyWall(::grpc::ClientContext* context, const ::seshat::DestroyWallRequest* request, ::seshat::DestroyWallResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetWallInfo(::grpc::ClientContext* context, const ::seshat::GetWallInfoRequest* request, ::seshat::GetWallInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetWallInfo(::grpc::ClientContext* context, const ::seshat::GetWallInfoRequest* request, ::seshat::GetWallInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Environment themes and materials
      virtual void GetThemes(::grpc::ClientContext* context, const ::seshat::GetThemesRequest* request, ::seshat::GetThemesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetThemes(::grpc::ClientContext* context, const ::seshat::GetThemesRequest* request, ::seshat::GetThemesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ApplyTheme(::grpc::ClientContext* context, const ::seshat::ApplyThemeRequest* request, ::seshat::ApplyThemeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ApplyTheme(::grpc::ClientContext* context, const ::seshat::ApplyThemeRequest* request, ::seshat::ApplyThemeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Shape templates
      virtual void GetShapeTemplates(::grpc::ClientContext* context, const ::seshat::GetShapeTemplatesRequest* request, ::seshat::GetShapeTemplatesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetShapeTemplates(::grpc::ClientContext* context, const ::seshat::GetShapeTemplatesRequest* request, ::seshat::GetShapeTemplatesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CreateCustomShape(::grpc::ClientContext* context, const ::seshat::CreateCustomShapeRequest* request, ::seshat::CreateCustomShapeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateCustomShape(::grpc::ClientContext* context, const ::seshat::CreateCustomShapeRequest* request, ::seshat::CreateCustomShapeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Capacity analysis
      virtual void AnalyzeCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeCapacityRequest* request, ::seshat::AnalyzeCapacityResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AnalyzeCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeCapacityRequest* request, ::seshat::AnalyzeCapacityResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetOptimalSize(::grpc::ClientContext* context, const ::seshat::GetOptimalSizeRequest* request, ::seshat::GetOptimalSizeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetOptimalSize(::grpc::ClientContext* context, const ::seshat::GetOptimalSizeRequest* request, ::seshat::GetOptimalSizeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateRoomResponse>* AsyncGenerateRoomRaw(::grpc::ClientContext* context, const ::seshat::GenerateRoomRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateRoomResponse>* PrepareAsyncGenerateRoomRaw(::grpc::ClientContext* context, const ::seshat::GenerateRoomRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateRoomTemplateResponse>* AsyncGenerateRoomWithTemplateRaw(::grpc::ClientContext* context, const ::seshat::GenerateRoomTemplateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateRoomTemplateResponse>* PrepareAsyncGenerateRoomWithTemplateRaw(::grpc::ClientContext* context, const ::seshat::GenerateRoomTemplateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateWallsResponse>* AsyncGenerateWallsRaw(::grpc::ClientContext* context, const ::seshat::GenerateWallsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GenerateWallsResponse>* PrepareAsyncGenerateWallsRaw(::grpc::ClientContext* context, const ::seshat::GenerateWallsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DestroyWallResponse>* AsyncDestroyWallRaw(::grpc::ClientContext* context, const ::seshat::DestroyWallRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::DestroyWallResponse>* PrepareAsyncDestroyWallRaw(::grpc::ClientContext* context, const ::seshat::DestroyWallRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetWallInfoResponse>* AsyncGetWallInfoRaw(::grpc::ClientContext* context, const ::seshat::GetWallInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetWallInfoResponse>* PrepareAsyncGetWallInfoRaw(::grpc::ClientContext* context, const ::seshat::GetWallInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetThemesResponse>* AsyncGetThemesRaw(::grpc::ClientContext* context, const ::seshat::GetThemesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetThemesResponse>* PrepareAsyncGetThemesRaw(::grpc::ClientContext* context, const ::seshat::GetThemesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ApplyThemeResponse>* AsyncApplyThemeRaw(::grpc::ClientContext* context, const ::seshat::ApplyThemeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ApplyThemeResponse>* PrepareAsyncApplyThemeRaw(::grpc::ClientContext* context, const ::seshat::ApplyThemeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetShapeTemplatesResponse>* AsyncGetShapeTemplatesRaw(::grpc::ClientContext* context, const ::seshat::GetShapeTemplatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetShapeTemplatesResponse>* PrepareAsyncGetShapeTemplatesRaw(::grpc::ClientContext* context, const ::seshat::GetShapeTemplatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateCustomShapeResponse>* AsyncCreateCustomShapeRaw(::grpc::ClientContext* context, const ::seshat::CreateCustomShapeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::CreateCustomShapeResponse>* PrepareAsyncCreateCustomShapeRaw(::grpc::ClientContext* context, const ::seshat::CreateCustomShapeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AnalyzeCapacityResponse>* AsyncAnalyzeCapacityRaw(::grpc::ClientContext* context, const ::seshat::AnalyzeCapacityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::AnalyzeCapacityResponse>* PrepareAsyncAnalyzeCapacityRaw(::grpc::ClientContext* context, const ::seshat::AnalyzeCapacityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetOptimalSizeResponse>* AsyncGetOptimalSizeRaw(::grpc::ClientContext* context, const ::seshat::GetOptimalSizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetOptimalSizeResponse>* PrepareAsyncGetOptimalSizeRaw(::grpc::ClientContext* context, const ::seshat::GetOptimalSizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GenerateRoom(::grpc::ClientContext* context, const ::seshat::GenerateRoomRequest& request, ::seshat::GenerateRoomResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GenerateRoomResponse>> AsyncGenerateRoom(::grpc::ClientContext* context, const ::seshat::GenerateRoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GenerateRoomResponse>>(AsyncGenerateRoomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GenerateRoomResponse>> PrepareAsyncGenerateRoom(::grpc::ClientContext* context, const ::seshat::GenerateRoomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GenerateRoomResponse>>(PrepareAsyncGenerateRoomRaw(context, request, cq));
    }
    ::grpc::Status GenerateRoomWithTemplate(::grpc::ClientContext* context, const ::seshat::GenerateRoomTemplateRequest& request, ::seshat::GenerateRoomTemplateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GenerateRoomTemplateResponse>> AsyncGenerateRoomWithTemplate(::grpc::ClientContext* context, const ::seshat::GenerateRoomTemplateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GenerateRoomTemplateResponse>>(AsyncGenerateRoomWithTemplateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GenerateRoomTemplateResponse>> PrepareAsyncGenerateRoomWithTemplate(::grpc::ClientContext* context, const ::seshat::GenerateRoomTemplateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GenerateRoomTemplateResponse>>(PrepareAsyncGenerateRoomWithTemplateRaw(context, request, cq));
    }
    ::grpc::Status GenerateWalls(::grpc::ClientContext* context, const ::seshat::GenerateWallsRequest& request, ::seshat::GenerateWallsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GenerateWallsResponse>> AsyncGenerateWalls(::grpc::ClientContext* context, const ::seshat::GenerateWallsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GenerateWallsResponse>>(AsyncGenerateWallsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GenerateWallsResponse>> PrepareAsyncGenerateWalls(::grpc::ClientContext* context, const ::seshat::GenerateWallsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GenerateWallsResponse>>(PrepareAsyncGenerateWallsRaw(context, request, cq));
    }
    ::grpc::Status DestroyWall(::grpc::ClientContext* context, const ::seshat::DestroyWallRequest& request, ::seshat::DestroyWallResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::DestroyWallResponse>> AsyncDestroyWall(::grpc::ClientContext* context, const ::seshat::DestroyWallRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::DestroyWallResponse>>(AsyncDestroyWallRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::DestroyWallResponse>> PrepareAsyncDestroyWall(::grpc::ClientContext* context, const ::seshat::DestroyWallRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::DestroyWallResponse>>(PrepareAsyncDestroyWallRaw(context, request, cq));
    }
    ::grpc::Status GetWallInfo(::grpc::ClientContext* context, const ::seshat::GetWallInfoRequest& request, ::seshat::GetWallInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetWallInfoResponse>> AsyncGetWallInfo(::grpc::ClientContext* context, const ::seshat::GetWallInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetWallInfoResponse>>(AsyncGetWallInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetWallInfoResponse>> PrepareAsyncGetWallInfo(::grpc::ClientContext* context, const ::seshat::GetWallInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetWallInfoResponse>>(PrepareAsyncGetWallInfoRaw(context, request, cq));
    }
    ::grpc::Status GetThemes(::grpc::ClientContext* context, const ::seshat::GetThemesRequest& request, ::seshat::GetThemesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetThemesResponse>> AsyncGetThemes(::grpc::ClientContext* context, const ::seshat::GetThemesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetThemesResponse>>(AsyncGetThemesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetThemesResponse>> PrepareAsyncGetThemes(::grpc::ClientContext* context, const ::seshat::GetThemesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetThemesResponse>>(PrepareAsyncGetThemesRaw(context, request, cq));
    }
    ::grpc::Status ApplyTheme(::grpc::ClientContext* context, const ::seshat::ApplyThemeRequest& request, ::seshat::ApplyThemeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ApplyThemeResponse>> AsyncApplyTheme(::grpc::ClientContext* context, const ::seshat::ApplyThemeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ApplyThemeResponse>>(AsyncApplyThemeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ApplyThemeResponse>> PrepareAsyncApplyTheme(::grpc::ClientContext* context, const ::seshat::ApplyThemeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ApplyThemeResponse>>(PrepareAsyncApplyThemeRaw(context, request, cq));
    }
    ::grpc::Status GetShapeTemplates(::grpc::ClientContext* context, const ::seshat::GetShapeTemplatesRequest& request, ::seshat::GetShapeTemplatesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetShapeTemplatesResponse>> AsyncGetShapeTemplates(::grpc::ClientContext* context, const ::seshat::GetShapeTemplatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetShapeTemplatesResponse>>(AsyncGetShapeTemplatesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetShapeTemplatesResponse>> PrepareAsyncGetShapeTemplates(::grpc::ClientContext* context, const ::seshat::GetShapeTemplatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetShapeTemplatesResponse>>(PrepareAsyncGetShapeTemplatesRaw(context, request, cq));
    }
    ::grpc::Status CreateCustomShape(::grpc::ClientContext* context, const ::seshat::CreateCustomShapeRequest& request, ::seshat::CreateCustomShapeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CreateCustomShapeResponse>> AsyncCreateCustomShape(::grpc::ClientContext* context, const ::seshat::CreateCustomShapeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CreateCustomShapeResponse>>(AsyncCreateCustomShapeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CreateCustomShapeResponse>> PrepareAsyncCreateCustomShape(::grpc::ClientContext* context, const ::seshat::CreateCustomShapeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::CreateCustomShapeResponse>>(PrepareAsyncCreateCustomShapeRaw(context, request, cq));
    }
    ::grpc::Status AnalyzeCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeCapacityRequest& request, ::seshat::AnalyzeCapacityResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::AnalyzeCapacityResponse>> AsyncAnalyzeCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeCapacityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::AnalyzeCapacityResponse>>(AsyncAnalyzeCapacityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::AnalyzeCapacityResponse>> PrepareAsyncAnalyzeCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeCapacityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::AnalyzeCapacityResponse>>(PrepareAsyncAnalyzeCapacityRaw(context, request, cq));
    }
    ::grpc::Status GetOptimalSize(::grpc::ClientContext* context, const ::seshat::GetOptimalSizeRequest& request, ::seshat::GetOptimalSizeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetOptimalSizeResponse>> AsyncGetOptimalSize(::grpc::ClientContext* context, const ::seshat::GetOptimalSizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetOptimalSizeResponse>>(AsyncGetOptimalSizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetOptimalSizeResponse>> PrepareAsyncGetOptimalSize(::grpc::ClientContext* context, const ::seshat::GetOptimalSizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetOptimalSizeResponse>>(PrepareAsyncGetOptimalSizeRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GenerateRoom(::grpc::ClientContext* context, const ::seshat::GenerateRoomRequest* request, ::seshat::GenerateRoomResponse* response, std::function<void(::grpc::Status)>) override;
      void GenerateRoom(::grpc::ClientContext* context, const ::seshat::GenerateRoomRequest* request, ::seshat::GenerateRoomResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GenerateRoomWithTemplate(::grpc::ClientContext* context, const ::seshat::GenerateRoomTemplateRequest* request, ::seshat::GenerateRoomTemplateResponse* response, std::function<void(::grpc::Status)>) override;
      void GenerateRoomWithTemplate(::grpc::ClientContext* context, const ::seshat::GenerateRoomTemplateRequest* request, ::seshat::GenerateRoomTemplateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GenerateWalls(::grpc::ClientContext* context, const ::seshat::GenerateWallsRequest* request, ::seshat::GenerateWallsResponse* response, std::function<void(::grpc::Status)>) override;
      void GenerateWalls(::grpc::ClientContext* context, const ::seshat::GenerateWallsRequest* request, ::seshat::GenerateWallsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DestroyWall(::grpc::ClientContext* context, const ::seshat::DestroyWallRequest* request, ::seshat::DestroyWallResponse* response, std::function<void(::grpc::Status)>) override;
      void DestroyWall(::grpc::ClientContext* context, const ::seshat::DestroyWallRequest* request, ::seshat::DestroyWallResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetWallInfo(::grpc::ClientContext* context, const ::seshat::GetWallInfoRequest* request, ::seshat::GetWallInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void GetWallInfo(::grpc::ClientContext* context, const ::seshat::GetWallInfoRequest* request, ::seshat::GetWallInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetThemes(::grpc::ClientContext* context, const ::seshat::GetThemesRequest* request, ::seshat::GetThemesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetThemes(::grpc::ClientContext* context, const ::seshat::GetThemesRequest* request, ::seshat::GetThemesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ApplyTheme(::grpc::ClientContext* context, const ::seshat::ApplyThemeRequest* request, ::seshat::ApplyThemeResponse* response, std::function<void(::grpc::Status)>) override;
      void ApplyTheme(::grpc::ClientContext* context, const ::seshat::ApplyThemeRequest* request, ::seshat::ApplyThemeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetShapeTemplates(::grpc::ClientContext* context, const ::seshat::GetShapeTemplatesRequest* request, ::seshat::GetShapeTemplatesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetShapeTemplates(::grpc::ClientContext* context, const ::seshat::GetShapeTemplatesRequest* request, ::seshat::GetShapeTemplatesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreateCustomShape(::grpc::ClientContext* context, const ::seshat::CreateCustomShapeRequest* request, ::seshat::CreateCustomShapeResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateCustomShape(::grpc::ClientContext* context, const ::seshat::CreateCustomShapeRequest* request, ::seshat::CreateCustomShapeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AnalyzeCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeCapacityRequest* request, ::seshat::AnalyzeCapacityResponse* response, std::function<void(::grpc::Status)>) override;
      void AnalyzeCapacity(::grpc::ClientContext* context, const ::seshat::AnalyzeCapacityRequest* request, ::seshat::AnalyzeCapacityResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetOptimalSize(::grpc::ClientContext* context, const ::seshat::GetOptimalSizeRequest* request, ::seshat::GetOptimalSizeResponse* response, std::function<void(::grpc::Status)>) override;
      void GetOptimalSize(::grpc::ClientContext* context, const ::seshat::GetOptimalSizeRequest* request, ::seshat::GetOptimalSizeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::seshat::GenerateRoomResponse>* AsyncGenerateRoomRaw(::grpc::ClientContext* context, const ::seshat::GenerateRoomRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GenerateRoomResponse>* PrepareAsyncGenerateRoomRaw(::grpc::ClientContext* context, const ::seshat::GenerateRoomRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GenerateRoomTemplateResponse>* AsyncGenerateRoomWithTemplateRaw(::grpc::ClientContext* context, const ::seshat::GenerateRoomTemplateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GenerateRoomTemplateResponse>* PrepareAsyncGenerateRoomWithTemplateRaw(::grpc::ClientContext* context, const ::seshat::GenerateRoomTemplateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GenerateWallsResponse>* AsyncGenerateWallsRaw(::grpc::ClientContext* context, const ::seshat::GenerateWallsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GenerateWallsResponse>* PrepareAsyncGenerateWallsRaw(::grpc::ClientContext* context, const ::seshat::GenerateWallsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::DestroyWallResponse>* AsyncDestroyWallRaw(::grpc::ClientContext* context, const ::seshat::DestroyWallRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::DestroyWallResponse>* PrepareAsyncDestroyWallRaw(::grpc::ClientContext* context, const ::seshat::DestroyWallRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetWallInfoResponse>* AsyncGetWallInfoRaw(::grpc::ClientContext* context, const ::seshat::GetWallInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetWallInfoResponse>* PrepareAsyncGetWallInfoRaw(::grpc::ClientContext* context, const ::seshat::GetWallInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetThemesResponse>* AsyncGetThemesRaw(::grpc::ClientContext* context, const ::seshat::GetThemesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetThemesResponse>* PrepareAsyncGetThemesRaw(::grpc::ClientContext* context, const ::seshat::GetThemesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::ApplyThemeResponse>* AsyncApplyThemeRaw(::grpc::ClientContext* context, const ::seshat::ApplyThemeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::ApplyThemeResponse>* PrepareAsyncApplyThemeRaw(::grpc::ClientContext* context, const ::seshat::ApplyThemeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetShapeTemplatesResponse>* AsyncGetShapeTemplatesRaw(::grpc::ClientContext* context, const ::seshat::GetShapeTemplatesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetShapeTemplatesResponse>* PrepareAsyncGetShapeTemplatesRaw(::grpc::ClientContext* context, const ::seshat::GetShapeTemplatesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::CreateCustomShapeResponse>* AsyncCreateCustomShapeRaw(::grpc::ClientContext* context, const ::seshat::CreateCustomShapeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::CreateCustomShapeResponse>* PrepareAsyncCreateCustomShapeRaw(::grpc::ClientContext* context, const ::seshat::CreateCustomShapeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::AnalyzeCapacityResponse>* AsyncAnalyzeCapacityRaw(::grpc::ClientContext* context, const ::seshat::AnalyzeCapacityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::AnalyzeCapacityResponse>* PrepareAsyncAnalyzeCapacityRaw(::grpc::ClientContext* context, const ::seshat::AnalyzeCapacityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetOptimalSizeResponse>* AsyncGetOptimalSizeRaw(::grpc::ClientContext* context, const ::seshat::GetOptimalSizeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetOptimalSizeResponse>* PrepareAsyncGetOptimalSizeRaw(::grpc::ClientContext* context, const ::seshat::GetOptimalSizeRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GenerateRoom_;
    const ::grpc::internal::RpcMethod rpcmethod_GenerateRoomWithTemplate_;
    const ::grpc::internal::RpcMethod rpcmethod_GenerateWalls_;
    const ::grpc::internal::RpcMethod rpcmethod_DestroyWall_;
    const ::grpc::internal::RpcMethod rpcmethod_GetWallInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_GetThemes_;
    const ::grpc::internal::RpcMethod rpcmethod_ApplyTheme_;
    const ::grpc::internal::RpcMethod rpcmethod_GetShapeTemplates_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateCustomShape_;
    const ::grpc::internal::RpcMethod rpcmethod_AnalyzeCapacity_;
    const ::grpc::internal::RpcMethod rpcmethod_GetOptimalSize_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Room generation
    virtual ::grpc::Status GenerateRoom(::grpc::ServerContext* context, const ::seshat::GenerateRoomRequest* request, ::seshat::GenerateRoomResponse* response);
    virtual ::grpc::Status GenerateRoomWithTemplate(::grpc::ServerContext* context, const ::seshat::GenerateRoomTemplateRequest* request, ::seshat::GenerateRoomTemplateResponse* response);
    // Wall system
    virtual ::grpc::Status GenerateWalls(::grpc::ServerContext* context, const ::seshat::GenerateWallsRequest* request, ::seshat::GenerateWallsResponse* response);
    virtual ::grpc::Status DestroyWall(::grpc::ServerContext* context, const ::seshat::DestroyWallRequest* request, ::seshat::DestroyWallResponse* response);
    virtual ::grpc::Status GetWallInfo(::grpc::ServerContext* context, const ::seshat::GetWallInfoRequest* request, ::seshat::GetWallInfoResponse* response);
    // Environment themes and materials
    virtual ::grpc::Status GetThemes(::grpc::ServerContext* context, const ::seshat::GetThemesRequest* request, ::seshat::GetThemesResponse* response);
    virtual ::grpc::Status ApplyTheme(::grpc::ServerContext* context, const ::seshat::ApplyThemeRequest* request, ::seshat::ApplyThemeResponse* response);
    // Shape templates
    virtual ::grpc::Status GetShapeTemplates(::grpc::ServerContext* context, const ::seshat::GetShapeTemplatesRequest* request, ::seshat::GetShapeTemplatesResponse* response);
    virtual ::grpc::Status CreateCustomShape(::grpc::ServerContext* context, const ::seshat::CreateCustomShapeRequest* request, ::seshat::CreateCustomShapeResponse* response);
    // Capacity analysis
    virtual ::grpc::Status AnalyzeCapacity(::grpc::ServerContext* context, const ::seshat::AnalyzeCapacityRequest* request, ::seshat::AnalyzeCapacityResponse* response);
    virtual ::grpc::Status GetOptimalSize(::grpc::ServerContext* context, const ::seshat::GetOptimalSizeRequest* request, ::seshat::GetOptimalSizeResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GenerateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GenerateRoom() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GenerateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateRoom(::grpc::ServerContext* /*context*/, const ::seshat::GenerateRoomRequest* /*request*/, ::seshat::GenerateRoomResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGenerateRoom(::grpc::ServerContext* context, ::seshat::GenerateRoomRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GenerateRoomResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GenerateRoomWithTemplate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GenerateRoomWithTemplate() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GenerateRoomWithTemplate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateRoomWithTemplate(::grpc::ServerContext* /*context*/, const ::seshat::GenerateRoomTemplateRequest* /*request*/, ::seshat::GenerateRoomTemplateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGenerateRoomWithTemplate(::grpc::ServerContext* context, ::seshat::GenerateRoomTemplateRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GenerateRoomTemplateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GenerateWalls : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GenerateWalls() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GenerateWalls() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateWalls(::grpc::ServerContext* /*context*/, const ::seshat::GenerateWallsRequest* /*request*/, ::seshat::GenerateWallsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGenerateWalls(::grpc::ServerContext* context, ::seshat::GenerateWallsRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GenerateWallsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DestroyWall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DestroyWall() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_DestroyWall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyWall(::grpc::ServerContext* /*context*/, const ::seshat::DestroyWallRequest* /*request*/, ::seshat::DestroyWallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyWall(::grpc::ServerContext* context, ::seshat::DestroyWallRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::DestroyWallResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetWallInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetWallInfo() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetWallInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWallInfo(::grpc::ServerContext* /*context*/, const ::seshat::GetWallInfoRequest* /*request*/, ::seshat::GetWallInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWallInfo(::grpc::ServerContext* context, ::seshat::GetWallInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GetWallInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetThemes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetThemes() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetThemes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetThemes(::grpc::ServerContext* /*context*/, const ::seshat::GetThemesRequest* /*request*/, ::seshat::GetThemesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetThemes(::grpc::ServerContext* context, ::seshat::GetThemesRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GetThemesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ApplyTheme : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ApplyTheme() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_ApplyTheme() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ApplyTheme(::grpc::ServerContext* /*context*/, const ::seshat::ApplyThemeRequest* /*request*/, ::seshat::ApplyThemeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestApplyTheme(::grpc::ServerContext* context, ::seshat::ApplyThemeRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::ApplyThemeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetShapeTemplates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetShapeTemplates() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetShapeTemplates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetShapeTemplates(::grpc::ServerContext* /*context*/, const ::seshat::GetShapeTemplatesRequest* /*request*/, ::seshat::GetShapeTemplatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetShapeTemplates(::grpc::ServerContext* context, ::seshat::GetShapeTemplatesRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GetShapeTemplatesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateCustomShape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateCustomShape() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_CreateCustomShape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateCustomShape(::grpc::ServerContext* /*context*/, const ::seshat::CreateCustomShapeRequest* /*request*/, ::seshat::CreateCustomShapeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateCustomShape(::grpc::ServerContext* context, ::seshat::CreateCustomShapeRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::CreateCustomShapeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AnalyzeCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AnalyzeCapacity() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_AnalyzeCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AnalyzeCapacity(::grpc::ServerContext* /*context*/, const ::seshat::AnalyzeCapacityRequest* /*request*/, ::seshat::AnalyzeCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAnalyzeCapacity(::grpc::ServerContext* context, ::seshat::AnalyzeCapacityRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::AnalyzeCapacityResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetOptimalSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetOptimalSize() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetOptimalSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOptimalSize(::grpc::ServerContext* /*context*/, const ::seshat::GetOptimalSizeRequest* /*request*/, ::seshat::GetOptimalSizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOptimalSize(::grpc::ServerContext* context, ::seshat::GetOptimalSizeRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GetOptimalSizeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GenerateRoom<WithAsyncMethod_GenerateRoomWithTemplate<WithAsyncMethod_GenerateWalls<WithAsyncMethod_DestroyWall<WithAsyncMethod_GetWallInfo<WithAsyncMethod_GetThemes<WithAsyncMethod_ApplyTheme<WithAsyncMethod_GetShapeTemplates<WithAsyncMethod_CreateCustomShape<WithAsyncMethod_AnalyzeCapacity<WithAsyncMethod_GetOptimalSize<Service > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GenerateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GenerateRoom() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GenerateRoomRequest, ::seshat::GenerateRoomResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GenerateRoomRequest* request, ::seshat::GenerateRoomResponse* response) { return this->GenerateRoom(context, request, response); }));}
    void SetMessageAllocatorFor_GenerateRoom(
        ::grpc::MessageAllocator< ::seshat::GenerateRoomRequest, ::seshat::GenerateRoomResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GenerateRoomRequest, ::seshat::GenerateRoomResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GenerateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateRoom(::grpc::ServerContext* /*context*/, const ::seshat::GenerateRoomRequest* /*request*/, ::seshat::GenerateRoomResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GenerateRoom(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GenerateRoomRequest* /*request*/, ::seshat::GenerateRoomResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GenerateRoomWithTemplate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GenerateRoomWithTemplate() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GenerateRoomTemplateRequest, ::seshat::GenerateRoomTemplateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GenerateRoomTemplateRequest* request, ::seshat::GenerateRoomTemplateResponse* response) { return this->GenerateRoomWithTemplate(context, request, response); }));}
    void SetMessageAllocatorFor_GenerateRoomWithTemplate(
        ::grpc::MessageAllocator< ::seshat::GenerateRoomTemplateRequest, ::seshat::GenerateRoomTemplateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GenerateRoomTemplateRequest, ::seshat::GenerateRoomTemplateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GenerateRoomWithTemplate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateRoomWithTemplate(::grpc::ServerContext* /*context*/, const ::seshat::GenerateRoomTemplateRequest* /*request*/, ::seshat::GenerateRoomTemplateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GenerateRoomWithTemplate(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GenerateRoomTemplateRequest* /*request*/, ::seshat::GenerateRoomTemplateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GenerateWalls : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GenerateWalls() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GenerateWallsRequest, ::seshat::GenerateWallsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GenerateWallsRequest* request, ::seshat::GenerateWallsResponse* response) { return this->GenerateWalls(context, request, response); }));}
    void SetMessageAllocatorFor_GenerateWalls(
        ::grpc::MessageAllocator< ::seshat::GenerateWallsRequest, ::seshat::GenerateWallsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GenerateWallsRequest, ::seshat::GenerateWallsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GenerateWalls() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateWalls(::grpc::ServerContext* /*context*/, const ::seshat::GenerateWallsRequest* /*request*/, ::seshat::GenerateWallsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GenerateWalls(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GenerateWallsRequest* /*request*/, ::seshat::GenerateWallsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DestroyWall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DestroyWall() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::DestroyWallRequest, ::seshat::DestroyWallResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::DestroyWallRequest* request, ::seshat::DestroyWallResponse* response) { return this->DestroyWall(context, request, response); }));}
    void SetMessageAllocatorFor_DestroyWall(
        ::grpc::MessageAllocator< ::seshat::DestroyWallRequest, ::seshat::DestroyWallResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::DestroyWallRequest, ::seshat::DestroyWallResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DestroyWall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyWall(::grpc::ServerContext* /*context*/, const ::seshat::DestroyWallRequest* /*request*/, ::seshat::DestroyWallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DestroyWall(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::DestroyWallRequest* /*request*/, ::seshat::DestroyWallResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetWallInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetWallInfo() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GetWallInfoRequest, ::seshat::GetWallInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GetWallInfoRequest* request, ::seshat::GetWallInfoResponse* response) { return this->GetWallInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetWallInfo(
        ::grpc::MessageAllocator< ::seshat::GetWallInfoRequest, ::seshat::GetWallInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GetWallInfoRequest, ::seshat::GetWallInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetWallInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWallInfo(::grpc::ServerContext* /*context*/, const ::seshat::GetWallInfoRequest* /*request*/, ::seshat::GetWallInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetWallInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GetWallInfoRequest* /*request*/, ::seshat::GetWallInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetThemes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetThemes() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GetThemesRequest, ::seshat::GetThemesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GetThemesRequest* request, ::seshat::GetThemesResponse* response) { return this->GetThemes(context, request, response); }));}
    void SetMessageAllocatorFor_GetThemes(
        ::grpc::MessageAllocator< ::seshat::GetThemesRequest, ::seshat::GetThemesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GetThemesRequest, ::seshat::GetThemesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetThemes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetThemes(::grpc::ServerContext* /*context*/, const ::seshat::GetThemesRequest* /*request*/, ::seshat::GetThemesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetThemes(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GetThemesRequest* /*request*/, ::seshat::GetThemesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ApplyTheme : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ApplyTheme() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::ApplyThemeRequest, ::seshat::ApplyThemeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::ApplyThemeRequest* request, ::seshat::ApplyThemeResponse* response) { return this->ApplyTheme(context, request, response); }));}
    void SetMessageAllocatorFor_ApplyTheme(
        ::grpc::MessageAllocator< ::seshat::ApplyThemeRequest, ::seshat::ApplyThemeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::ApplyThemeRequest, ::seshat::ApplyThemeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ApplyTheme() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ApplyTheme(::grpc::ServerContext* /*context*/, const ::seshat::ApplyThemeRequest* /*request*/, ::seshat::ApplyThemeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ApplyTheme(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::ApplyThemeRequest* /*request*/, ::seshat::ApplyThemeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetShapeTemplates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetShapeTemplates() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GetShapeTemplatesRequest, ::seshat::GetShapeTemplatesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GetShapeTemplatesRequest* request, ::seshat::GetShapeTemplatesResponse* response) { return this->GetShapeTemplates(context, request, response); }));}
    void SetMessageAllocatorFor_GetShapeTemplates(
        ::grpc::MessageAllocator< ::seshat::GetShapeTemplatesRequest, ::seshat::GetShapeTemplatesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GetShapeTemplatesRequest, ::seshat::GetShapeTemplatesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetShapeTemplates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetShapeTemplates(::grpc::ServerContext* /*context*/, const ::seshat::GetShapeTemplatesRequest* /*request*/, ::seshat::GetShapeTemplatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetShapeTemplates(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GetShapeTemplatesRequest* /*request*/, ::seshat::GetShapeTemplatesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateCustomShape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateCustomShape() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::CreateCustomShapeRequest, ::seshat::CreateCustomShapeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::CreateCustomShapeRequest* request, ::seshat::CreateCustomShapeResponse* response) { return this->CreateCustomShape(context, request, response); }));}
    void SetMessageAllocatorFor_CreateCustomShape(
        ::grpc::MessageAllocator< ::seshat::CreateCustomShapeRequest, ::seshat::CreateCustomShapeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::CreateCustomShapeRequest, ::seshat::CreateCustomShapeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateCustomShape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateCustomShape(::grpc::ServerContext* /*context*/, const ::seshat::CreateCustomShapeRequest* /*request*/, ::seshat::CreateCustomShapeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateCustomShape(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::CreateCustomShapeRequest* /*request*/, ::seshat::CreateCustomShapeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AnalyzeCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AnalyzeCapacity() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::AnalyzeCapacityRequest, ::seshat::AnalyzeCapacityResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::AnalyzeCapacityRequest* request, ::seshat::AnalyzeCapacityResponse* response) { return this->AnalyzeCapacity(context, request, response); }));}
    void SetMessageAllocatorFor_AnalyzeCapacity(
        ::grpc::MessageAllocator< ::seshat::AnalyzeCapacityRequest, ::seshat::AnalyzeCapacityResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::AnalyzeCapacityRequest, ::seshat::AnalyzeCapacityResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AnalyzeCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AnalyzeCapacity(::grpc::ServerContext* /*context*/, const ::seshat::AnalyzeCapacityRequest* /*request*/, ::seshat::AnalyzeCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AnalyzeCapacity(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::AnalyzeCapacityRequest* /*request*/, ::seshat::AnalyzeCapacityResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetOptimalSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetOptimalSize() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GetOptimalSizeRequest, ::seshat::GetOptimalSizeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GetOptimalSizeRequest* request, ::seshat::GetOptimalSizeResponse* response) { return this->GetOptimalSize(context, request, response); }));}
    void SetMessageAllocatorFor_GetOptimalSize(
        ::grpc::MessageAllocator< ::seshat::GetOptimalSizeRequest, ::seshat::GetOptimalSizeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GetOptimalSizeRequest, ::seshat::GetOptimalSizeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetOptimalSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOptimalSize(::grpc::ServerContext* /*context*/, const ::seshat::GetOptimalSizeRequest* /*request*/, ::seshat::GetOptimalSizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetOptimalSize(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GetOptimalSizeRequest* /*request*/, ::seshat::GetOptimalSizeResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GenerateRoom<WithCallbackMethod_GenerateRoomWithTemplate<WithCallbackMethod_GenerateWalls<WithCallbackMethod_DestroyWall<WithCallbackMethod_GetWallInfo<WithCallbackMethod_GetThemes<WithCallbackMethod_ApplyTheme<WithCallbackMethod_GetShapeTemplates<WithCallbackMethod_CreateCustomShape<WithCallbackMethod_AnalyzeCapacity<WithCallbackMethod_GetOptimalSize<Service > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GenerateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GenerateRoom() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GenerateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateRoom(::grpc::ServerContext* /*context*/, const ::seshat::GenerateRoomRequest* /*request*/, ::seshat::GenerateRoomResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GenerateRoomWithTemplate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GenerateRoomWithTemplate() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GenerateRoomWithTemplate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateRoomWithTemplate(::grpc::ServerContext* /*context*/, const ::seshat::GenerateRoomTemplateRequest* /*request*/, ::seshat::GenerateRoomTemplateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GenerateWalls : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GenerateWalls() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GenerateWalls() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateWalls(::grpc::ServerContext* /*context*/, const ::seshat::GenerateWallsRequest* /*request*/, ::seshat::GenerateWallsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DestroyWall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DestroyWall() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_DestroyWall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyWall(::grpc::ServerContext* /*context*/, const ::seshat::DestroyWallRequest* /*request*/, ::seshat::DestroyWallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetWallInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetWallInfo() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetWallInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWallInfo(::grpc::ServerContext* /*context*/, const ::seshat::GetWallInfoRequest* /*request*/, ::seshat::GetWallInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetThemes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetThemes() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetThemes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetThemes(::grpc::ServerContext* /*context*/, const ::seshat::GetThemesRequest* /*request*/, ::seshat::GetThemesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ApplyTheme : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ApplyTheme() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_ApplyTheme() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ApplyTheme(::grpc::ServerContext* /*context*/, const ::seshat::ApplyThemeRequest* /*request*/, ::seshat::ApplyThemeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetShapeTemplates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetShapeTemplates() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetShapeTemplates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetShapeTemplates(::grpc::ServerContext* /*context*/, const ::seshat::GetShapeTemplatesRequest* /*request*/, ::seshat::GetShapeTemplatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateCustomShape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateCustomShape() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_CreateCustomShape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateCustomShape(::grpc::ServerContext* /*context*/, const ::seshat::CreateCustomShapeRequest* /*request*/, ::seshat::CreateCustomShapeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AnalyzeCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AnalyzeCapacity() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_AnalyzeCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AnalyzeCapacity(::grpc::ServerContext* /*context*/, const ::seshat::AnalyzeCapacityRequest* /*request*/, ::seshat::AnalyzeCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetOptimalSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetOptimalSize() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetOptimalSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOptimalSize(::grpc::ServerContext* /*context*/, const ::seshat::GetOptimalSizeRequest* /*request*/, ::seshat::GetOptimalSizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GenerateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GenerateRoom() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GenerateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateRoom(::grpc::ServerContext* /*context*/, const ::seshat::GenerateRoomRequest* /*request*/, ::seshat::GenerateRoomResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGenerateRoom(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GenerateRoomWithTemplate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GenerateRoomWithTemplate() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GenerateRoomWithTemplate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateRoomWithTemplate(::grpc::ServerContext* /*context*/, const ::seshat::GenerateRoomTemplateRequest* /*request*/, ::seshat::GenerateRoomTemplateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGenerateRoomWithTemplate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GenerateWalls : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GenerateWalls() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GenerateWalls() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateWalls(::grpc::ServerContext* /*context*/, const ::seshat::GenerateWallsRequest* /*request*/, ::seshat::GenerateWallsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGenerateWalls(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DestroyWall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DestroyWall() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_DestroyWall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyWall(::grpc::ServerContext* /*context*/, const ::seshat::DestroyWallRequest* /*request*/, ::seshat::DestroyWallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyWall(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetWallInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetWallInfo() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetWallInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWallInfo(::grpc::ServerContext* /*context*/, const ::seshat::GetWallInfoRequest* /*request*/, ::seshat::GetWallInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWallInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetThemes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetThemes() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetThemes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetThemes(::grpc::ServerContext* /*context*/, const ::seshat::GetThemesRequest* /*request*/, ::seshat::GetThemesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetThemes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ApplyTheme : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ApplyTheme() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_ApplyTheme() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ApplyTheme(::grpc::ServerContext* /*context*/, const ::seshat::ApplyThemeRequest* /*request*/, ::seshat::ApplyThemeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestApplyTheme(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetShapeTemplates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetShapeTemplates() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetShapeTemplates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetShapeTemplates(::grpc::ServerContext* /*context*/, const ::seshat::GetShapeTemplatesRequest* /*request*/, ::seshat::GetShapeTemplatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetShapeTemplates(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateCustomShape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateCustomShape() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_CreateCustomShape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateCustomShape(::grpc::ServerContext* /*context*/, const ::seshat::CreateCustomShapeRequest* /*request*/, ::seshat::CreateCustomShapeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateCustomShape(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AnalyzeCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AnalyzeCapacity() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_AnalyzeCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AnalyzeCapacity(::grpc::ServerContext* /*context*/, const ::seshat::AnalyzeCapacityRequest* /*request*/, ::seshat::AnalyzeCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAnalyzeCapacity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetOptimalSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetOptimalSize() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetOptimalSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOptimalSize(::grpc::ServerContext* /*context*/, const ::seshat::GetOptimalSizeRequest* /*request*/, ::seshat::GetOptimalSizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOptimalSize(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GenerateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GenerateRoom() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GenerateRoom(context, request, response); }));
    }
    ~WithRawCallbackMethod_GenerateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateRoom(::grpc::ServerContext* /*context*/, const ::seshat::GenerateRoomRequest* /*request*/, ::seshat::GenerateRoomResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GenerateRoom(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GenerateRoomWithTemplate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GenerateRoomWithTemplate() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GenerateRoomWithTemplate(context, request, response); }));
    }
    ~WithRawCallbackMethod_GenerateRoomWithTemplate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateRoomWithTemplate(::grpc::ServerContext* /*context*/, const ::seshat::GenerateRoomTemplateRequest* /*request*/, ::seshat::GenerateRoomTemplateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GenerateRoomWithTemplate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GenerateWalls : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GenerateWalls() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GenerateWalls(context, request, response); }));
    }
    ~WithRawCallbackMethod_GenerateWalls() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GenerateWalls(::grpc::ServerContext* /*context*/, const ::seshat::GenerateWallsRequest* /*request*/, ::seshat::GenerateWallsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GenerateWalls(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DestroyWall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DestroyWall() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DestroyWall(context, request, response); }));
    }
    ~WithRawCallbackMethod_DestroyWall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyWall(::grpc::ServerContext* /*context*/, const ::seshat::DestroyWallRequest* /*request*/, ::seshat::DestroyWallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DestroyWall(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetWallInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetWallInfo() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetWallInfo(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetWallInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWallInfo(::grpc::ServerContext* /*context*/, const ::seshat::GetWallInfoRequest* /*request*/, ::seshat::GetWallInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetWallInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetThemes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetThemes() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetThemes(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetThemes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetThemes(::grpc::ServerContext* /*context*/, const ::seshat::GetThemesRequest* /*request*/, ::seshat::GetThemesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetThemes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ApplyTheme : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ApplyTheme() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ApplyTheme(context, request, response); }));
    }
    ~WithRawCallbackMethod_ApplyTheme() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ApplyTheme(::grpc::ServerContext* /*context*/, const ::seshat::ApplyThemeRequest* /*request*/, ::seshat::ApplyThemeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ApplyTheme(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetShapeTemplates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetShapeTemplates() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetShapeTemplates(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetShapeTemplates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetShapeTemplates(::grpc::ServerContext* /*context*/, const ::seshat::GetShapeTemplatesRequest* /*request*/, ::seshat::GetShapeTemplatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetShapeTemplates(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateCustomShape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateCustomShape() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateCustomShape(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateCustomShape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateCustomShape(::grpc::ServerContext* /*context*/, const ::seshat::CreateCustomShapeRequest* /*request*/, ::seshat::CreateCustomShapeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateCustomShape(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AnalyzeCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AnalyzeCapacity() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AnalyzeCapacity(context, request, response); }));
    }
    ~WithRawCallbackMethod_AnalyzeCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AnalyzeCapacity(::grpc::ServerContext* /*context*/, const ::seshat::AnalyzeCapacityRequest* /*request*/, ::seshat::AnalyzeCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AnalyzeCapacity(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetOptimalSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetOptimalSize() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetOptimalSize(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetOptimalSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOptimalSize(::grpc::ServerContext* /*context*/, const ::seshat::GetOptimalSizeRequest* /*request*/, ::seshat::GetOptimalSizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetOptimalSize(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GenerateRoom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GenerateRoom() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GenerateRoomRequest, ::seshat::GenerateRoomResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GenerateRoomRequest, ::seshat::GenerateRoomResponse>* streamer) {
                       return this->StreamedGenerateRoom(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GenerateRoom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GenerateRoom(::grpc::ServerContext* /*context*/, const ::seshat::GenerateRoomRequest* /*request*/, ::seshat::GenerateRoomResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGenerateRoom(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GenerateRoomRequest,::seshat::GenerateRoomResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GenerateRoomWithTemplate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GenerateRoomWithTemplate() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GenerateRoomTemplateRequest, ::seshat::GenerateRoomTemplateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GenerateRoomTemplateRequest, ::seshat::GenerateRoomTemplateResponse>* streamer) {
                       return this->StreamedGenerateRoomWithTemplate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GenerateRoomWithTemplate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GenerateRoomWithTemplate(::grpc::ServerContext* /*context*/, const ::seshat::GenerateRoomTemplateRequest* /*request*/, ::seshat::GenerateRoomTemplateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGenerateRoomWithTemplate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GenerateRoomTemplateRequest,::seshat::GenerateRoomTemplateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GenerateWalls : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GenerateWalls() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GenerateWallsRequest, ::seshat::GenerateWallsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GenerateWallsRequest, ::seshat::GenerateWallsResponse>* streamer) {
                       return this->StreamedGenerateWalls(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GenerateWalls() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GenerateWalls(::grpc::ServerContext* /*context*/, const ::seshat::GenerateWallsRequest* /*request*/, ::seshat::GenerateWallsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGenerateWalls(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GenerateWallsRequest,::seshat::GenerateWallsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DestroyWall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DestroyWall() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::DestroyWallRequest, ::seshat::DestroyWallResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::DestroyWallRequest, ::seshat::DestroyWallResponse>* streamer) {
                       return this->StreamedDestroyWall(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DestroyWall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DestroyWall(::grpc::ServerContext* /*context*/, const ::seshat::DestroyWallRequest* /*request*/, ::seshat::DestroyWallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDestroyWall(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::DestroyWallRequest,::seshat::DestroyWallResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetWallInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetWallInfo() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GetWallInfoRequest, ::seshat::GetWallInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GetWallInfoRequest, ::seshat::GetWallInfoResponse>* streamer) {
                       return this->StreamedGetWallInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetWallInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetWallInfo(::grpc::ServerContext* /*context*/, const ::seshat::GetWallInfoRequest* /*request*/, ::seshat::GetWallInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetWallInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GetWallInfoRequest,::seshat::GetWallInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetThemes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetThemes() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GetThemesRequest, ::seshat::GetThemesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GetThemesRequest, ::seshat::GetThemesResponse>* streamer) {
                       return this->StreamedGetThemes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetThemes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetThemes(::grpc::ServerContext* /*context*/, const ::seshat::GetThemesRequest* /*request*/, ::seshat::GetThemesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetThemes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GetThemesRequest,::seshat::GetThemesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ApplyTheme : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ApplyTheme() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::ApplyThemeRequest, ::seshat::ApplyThemeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::ApplyThemeRequest, ::seshat::ApplyThemeResponse>* streamer) {
                       return this->StreamedApplyTheme(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ApplyTheme() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ApplyTheme(::grpc::ServerContext* /*context*/, const ::seshat::ApplyThemeRequest* /*request*/, ::seshat::ApplyThemeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedApplyTheme(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::ApplyThemeRequest,::seshat::ApplyThemeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetShapeTemplates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetShapeTemplates() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GetShapeTemplatesRequest, ::seshat::GetShapeTemplatesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GetShapeTemplatesRequest, ::seshat::GetShapeTemplatesResponse>* streamer) {
                       return this->StreamedGetShapeTemplates(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetShapeTemplates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetShapeTemplates(::grpc::ServerContext* /*context*/, const ::seshat::GetShapeTemplatesRequest* /*request*/, ::seshat::GetShapeTemplatesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetShapeTemplates(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GetShapeTemplatesRequest,::seshat::GetShapeTemplatesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateCustomShape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateCustomShape() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::CreateCustomShapeRequest, ::seshat::CreateCustomShapeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::CreateCustomShapeRequest, ::seshat::CreateCustomShapeResponse>* streamer) {
                       return this->StreamedCreateCustomShape(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateCustomShape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateCustomShape(::grpc::ServerContext* /*context*/, const ::seshat::CreateCustomShapeRequest* /*request*/, ::seshat::CreateCustomShapeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateCustomShape(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::CreateCustomShapeRequest,::seshat::CreateCustomShapeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AnalyzeCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AnalyzeCapacity() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::AnalyzeCapacityRequest, ::seshat::AnalyzeCapacityResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::AnalyzeCapacityRequest, ::seshat::AnalyzeCapacityResponse>* streamer) {
                       return this->StreamedAnalyzeCapacity(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AnalyzeCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AnalyzeCapacity(::grpc::ServerContext* /*context*/, const ::seshat::AnalyzeCapacityRequest* /*request*/, ::seshat::AnalyzeCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAnalyzeCapacity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::AnalyzeCapacityRequest,::seshat::AnalyzeCapacityResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetOptimalSize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetOptimalSize() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GetOptimalSizeRequest, ::seshat::GetOptimalSizeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GetOptimalSizeRequest, ::seshat::GetOptimalSizeResponse>* streamer) {
                       return this->StreamedGetOptimalSize(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetOptimalSize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetOptimalSize(::grpc::ServerContext* /*context*/, const ::seshat::GetOptimalSizeRequest* /*request*/, ::seshat::GetOptimalSizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetOptimalSize(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GetOptimalSizeRequest,::seshat::GetOptimalSizeResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GenerateRoom<WithStreamedUnaryMethod_GenerateRoomWithTemplate<WithStreamedUnaryMethod_GenerateWalls<WithStreamedUnaryMethod_DestroyWall<WithStreamedUnaryMethod_GetWallInfo<WithStreamedUnaryMethod_GetThemes<WithStreamedUnaryMethod_ApplyTheme<WithStreamedUnaryMethod_GetShapeTemplates<WithStreamedUnaryMethod_CreateCustomShape<WithStreamedUnaryMethod_AnalyzeCapacity<WithStreamedUnaryMethod_GetOptimalSize<Service > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GenerateRoom<WithStreamedUnaryMethod_GenerateRoomWithTemplate<WithStreamedUnaryMethod_GenerateWalls<WithStreamedUnaryMethod_DestroyWall<WithStreamedUnaryMethod_GetWallInfo<WithStreamedUnaryMethod_GetThemes<WithStreamedUnaryMethod_ApplyTheme<WithStreamedUnaryMethod_GetShapeTemplates<WithStreamedUnaryMethod_CreateCustomShape<WithStreamedUnaryMethod_AnalyzeCapacity<WithStreamedUnaryMethod_GetOptimalSize<Service > > > > > > > > > > > StreamedService;
};

}  // namespace seshat


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_seshat_2fenvironments_2eproto__INCLUDED
