// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: seshat/events.proto
#ifndef GRPC_seshat_2fevents_2eproto__INCLUDED
#define GRPC_seshat_2fevents_2eproto__INCLUDED

#include "seshat/events.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace seshat {

// Event system service - exposes all events toolkit functionality
class EventService final {
 public:
  static constexpr char const* service_full_name() {
    return "seshat.EventService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Publish an event to the bus
    virtual ::grpc::Status PublishEvent(::grpc::ClientContext* context, const ::seshat::PublishEventRequest& request, ::seshat::PublishEventResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::PublishEventResponse>> AsyncPublishEvent(::grpc::ClientContext* context, const ::seshat::PublishEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::PublishEventResponse>>(AsyncPublishEventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::PublishEventResponse>> PrepareAsyncPublishEvent(::grpc::ClientContext* context, const ::seshat::PublishEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::PublishEventResponse>>(PrepareAsyncPublishEventRaw(context, request, cq));
    }
    // Subscribe to specific event types (streaming)
    std::unique_ptr< ::grpc::ClientReaderInterface< ::seshat::GameEvent>> SubscribeToEvents(::grpc::ClientContext* context, const ::seshat::SubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::seshat::GameEvent>>(SubscribeToEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::seshat::GameEvent>> AsyncSubscribeToEvents(::grpc::ClientContext* context, const ::seshat::SubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::seshat::GameEvent>>(AsyncSubscribeToEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::seshat::GameEvent>> PrepareAsyncSubscribeToEvents(::grpc::ClientContext* context, const ::seshat::SubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::seshat::GameEvent>>(PrepareAsyncSubscribeToEventsRaw(context, request, cq));
    }
    // Subscribe to all events (streaming)
    std::unique_ptr< ::grpc::ClientReaderInterface< ::seshat::GameEvent>> SubscribeToAllEvents(::grpc::ClientContext* context, const ::seshat::SubscribeAllRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::seshat::GameEvent>>(SubscribeToAllEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::seshat::GameEvent>> AsyncSubscribeToAllEvents(::grpc::ClientContext* context, const ::seshat::SubscribeAllRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::seshat::GameEvent>>(AsyncSubscribeToAllEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::seshat::GameEvent>> PrepareAsyncSubscribeToAllEvents(::grpc::ClientContext* context, const ::seshat::SubscribeAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::seshat::GameEvent>>(PrepareAsyncSubscribeToAllEventsRaw(context, request, cq));
    }
    // Get event history
    virtual ::grpc::Status GetEventHistory(::grpc::ClientContext* context, const ::seshat::EventHistoryRequest& request, ::seshat::EventHistoryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::EventHistoryResponse>> AsyncGetEventHistory(::grpc::ClientContext* context, const ::seshat::EventHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::EventHistoryResponse>>(AsyncGetEventHistoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::EventHistoryResponse>> PrepareAsyncGetEventHistory(::grpc::ClientContext* context, const ::seshat::EventHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::EventHistoryResponse>>(PrepareAsyncGetEventHistoryRaw(context, request, cq));
    }
    // Clear event history
    virtual ::grpc::Status ClearEventHistory(::grpc::ClientContext* context, const ::seshat::ClearEventHistoryRequest& request, ::seshat::ClearEventHistoryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ClearEventHistoryResponse>> AsyncClearEventHistory(::grpc::ClientContext* context, const ::seshat::ClearEventHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ClearEventHistoryResponse>>(AsyncClearEventHistoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ClearEventHistoryResponse>> PrepareAsyncClearEventHistory(::grpc::ClientContext* context, const ::seshat::ClearEventHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ClearEventHistoryResponse>>(PrepareAsyncClearEventHistoryRaw(context, request, cq));
    }
    // Get active subscriptions
    virtual ::grpc::Status GetSubscriptions(::grpc::ClientContext* context, const ::seshat::GetSubscriptionsRequest& request, ::seshat::GetSubscriptionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSubscriptionsResponse>> AsyncGetSubscriptions(::grpc::ClientContext* context, const ::seshat::GetSubscriptionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSubscriptionsResponse>>(AsyncGetSubscriptionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSubscriptionsResponse>> PrepareAsyncGetSubscriptions(::grpc::ClientContext* context, const ::seshat::GetSubscriptionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSubscriptionsResponse>>(PrepareAsyncGetSubscriptionsRaw(context, request, cq));
    }
    // Unsubscribe from events
    virtual ::grpc::Status Unsubscribe(::grpc::ClientContext* context, const ::seshat::UnsubscribeRequest& request, ::seshat::UnsubscribeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UnsubscribeResponse>> AsyncUnsubscribe(::grpc::ClientContext* context, const ::seshat::UnsubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UnsubscribeResponse>>(AsyncUnsubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UnsubscribeResponse>> PrepareAsyncUnsubscribe(::grpc::ClientContext* context, const ::seshat::UnsubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UnsubscribeResponse>>(PrepareAsyncUnsubscribeRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Publish an event to the bus
      virtual void PublishEvent(::grpc::ClientContext* context, const ::seshat::PublishEventRequest* request, ::seshat::PublishEventResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PublishEvent(::grpc::ClientContext* context, const ::seshat::PublishEventRequest* request, ::seshat::PublishEventResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Subscribe to specific event types (streaming)
      virtual void SubscribeToEvents(::grpc::ClientContext* context, const ::seshat::SubscribeRequest* request, ::grpc::ClientReadReactor< ::seshat::GameEvent>* reactor) = 0;
      // Subscribe to all events (streaming)
      virtual void SubscribeToAllEvents(::grpc::ClientContext* context, const ::seshat::SubscribeAllRequest* request, ::grpc::ClientReadReactor< ::seshat::GameEvent>* reactor) = 0;
      // Get event history
      virtual void GetEventHistory(::grpc::ClientContext* context, const ::seshat::EventHistoryRequest* request, ::seshat::EventHistoryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetEventHistory(::grpc::ClientContext* context, const ::seshat::EventHistoryRequest* request, ::seshat::EventHistoryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Clear event history
      virtual void ClearEventHistory(::grpc::ClientContext* context, const ::seshat::ClearEventHistoryRequest* request, ::seshat::ClearEventHistoryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ClearEventHistory(::grpc::ClientContext* context, const ::seshat::ClearEventHistoryRequest* request, ::seshat::ClearEventHistoryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Get active subscriptions
      virtual void GetSubscriptions(::grpc::ClientContext* context, const ::seshat::GetSubscriptionsRequest* request, ::seshat::GetSubscriptionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSubscriptions(::grpc::ClientContext* context, const ::seshat::GetSubscriptionsRequest* request, ::seshat::GetSubscriptionsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Unsubscribe from events
      virtual void Unsubscribe(::grpc::ClientContext* context, const ::seshat::UnsubscribeRequest* request, ::seshat::UnsubscribeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Unsubscribe(::grpc::ClientContext* context, const ::seshat::UnsubscribeRequest* request, ::seshat::UnsubscribeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::PublishEventResponse>* AsyncPublishEventRaw(::grpc::ClientContext* context, const ::seshat::PublishEventRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::PublishEventResponse>* PrepareAsyncPublishEventRaw(::grpc::ClientContext* context, const ::seshat::PublishEventRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::seshat::GameEvent>* SubscribeToEventsRaw(::grpc::ClientContext* context, const ::seshat::SubscribeRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::seshat::GameEvent>* AsyncSubscribeToEventsRaw(::grpc::ClientContext* context, const ::seshat::SubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::seshat::GameEvent>* PrepareAsyncSubscribeToEventsRaw(::grpc::ClientContext* context, const ::seshat::SubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::seshat::GameEvent>* SubscribeToAllEventsRaw(::grpc::ClientContext* context, const ::seshat::SubscribeAllRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::seshat::GameEvent>* AsyncSubscribeToAllEventsRaw(::grpc::ClientContext* context, const ::seshat::SubscribeAllRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::seshat::GameEvent>* PrepareAsyncSubscribeToAllEventsRaw(::grpc::ClientContext* context, const ::seshat::SubscribeAllRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::EventHistoryResponse>* AsyncGetEventHistoryRaw(::grpc::ClientContext* context, const ::seshat::EventHistoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::EventHistoryResponse>* PrepareAsyncGetEventHistoryRaw(::grpc::ClientContext* context, const ::seshat::EventHistoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ClearEventHistoryResponse>* AsyncClearEventHistoryRaw(::grpc::ClientContext* context, const ::seshat::ClearEventHistoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::ClearEventHistoryResponse>* PrepareAsyncClearEventHistoryRaw(::grpc::ClientContext* context, const ::seshat::ClearEventHistoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSubscriptionsResponse>* AsyncGetSubscriptionsRaw(::grpc::ClientContext* context, const ::seshat::GetSubscriptionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::GetSubscriptionsResponse>* PrepareAsyncGetSubscriptionsRaw(::grpc::ClientContext* context, const ::seshat::GetSubscriptionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UnsubscribeResponse>* AsyncUnsubscribeRaw(::grpc::ClientContext* context, const ::seshat::UnsubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::seshat::UnsubscribeResponse>* PrepareAsyncUnsubscribeRaw(::grpc::ClientContext* context, const ::seshat::UnsubscribeRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status PublishEvent(::grpc::ClientContext* context, const ::seshat::PublishEventRequest& request, ::seshat::PublishEventResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::PublishEventResponse>> AsyncPublishEvent(::grpc::ClientContext* context, const ::seshat::PublishEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::PublishEventResponse>>(AsyncPublishEventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::PublishEventResponse>> PrepareAsyncPublishEvent(::grpc::ClientContext* context, const ::seshat::PublishEventRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::PublishEventResponse>>(PrepareAsyncPublishEventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::seshat::GameEvent>> SubscribeToEvents(::grpc::ClientContext* context, const ::seshat::SubscribeRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::seshat::GameEvent>>(SubscribeToEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::seshat::GameEvent>> AsyncSubscribeToEvents(::grpc::ClientContext* context, const ::seshat::SubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::seshat::GameEvent>>(AsyncSubscribeToEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::seshat::GameEvent>> PrepareAsyncSubscribeToEvents(::grpc::ClientContext* context, const ::seshat::SubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::seshat::GameEvent>>(PrepareAsyncSubscribeToEventsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::seshat::GameEvent>> SubscribeToAllEvents(::grpc::ClientContext* context, const ::seshat::SubscribeAllRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::seshat::GameEvent>>(SubscribeToAllEventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::seshat::GameEvent>> AsyncSubscribeToAllEvents(::grpc::ClientContext* context, const ::seshat::SubscribeAllRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::seshat::GameEvent>>(AsyncSubscribeToAllEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::seshat::GameEvent>> PrepareAsyncSubscribeToAllEvents(::grpc::ClientContext* context, const ::seshat::SubscribeAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::seshat::GameEvent>>(PrepareAsyncSubscribeToAllEventsRaw(context, request, cq));
    }
    ::grpc::Status GetEventHistory(::grpc::ClientContext* context, const ::seshat::EventHistoryRequest& request, ::seshat::EventHistoryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::EventHistoryResponse>> AsyncGetEventHistory(::grpc::ClientContext* context, const ::seshat::EventHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::EventHistoryResponse>>(AsyncGetEventHistoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::EventHistoryResponse>> PrepareAsyncGetEventHistory(::grpc::ClientContext* context, const ::seshat::EventHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::EventHistoryResponse>>(PrepareAsyncGetEventHistoryRaw(context, request, cq));
    }
    ::grpc::Status ClearEventHistory(::grpc::ClientContext* context, const ::seshat::ClearEventHistoryRequest& request, ::seshat::ClearEventHistoryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ClearEventHistoryResponse>> AsyncClearEventHistory(::grpc::ClientContext* context, const ::seshat::ClearEventHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ClearEventHistoryResponse>>(AsyncClearEventHistoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ClearEventHistoryResponse>> PrepareAsyncClearEventHistory(::grpc::ClientContext* context, const ::seshat::ClearEventHistoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::ClearEventHistoryResponse>>(PrepareAsyncClearEventHistoryRaw(context, request, cq));
    }
    ::grpc::Status GetSubscriptions(::grpc::ClientContext* context, const ::seshat::GetSubscriptionsRequest& request, ::seshat::GetSubscriptionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSubscriptionsResponse>> AsyncGetSubscriptions(::grpc::ClientContext* context, const ::seshat::GetSubscriptionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSubscriptionsResponse>>(AsyncGetSubscriptionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSubscriptionsResponse>> PrepareAsyncGetSubscriptions(::grpc::ClientContext* context, const ::seshat::GetSubscriptionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::GetSubscriptionsResponse>>(PrepareAsyncGetSubscriptionsRaw(context, request, cq));
    }
    ::grpc::Status Unsubscribe(::grpc::ClientContext* context, const ::seshat::UnsubscribeRequest& request, ::seshat::UnsubscribeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::UnsubscribeResponse>> AsyncUnsubscribe(::grpc::ClientContext* context, const ::seshat::UnsubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::UnsubscribeResponse>>(AsyncUnsubscribeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::UnsubscribeResponse>> PrepareAsyncUnsubscribe(::grpc::ClientContext* context, const ::seshat::UnsubscribeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::seshat::UnsubscribeResponse>>(PrepareAsyncUnsubscribeRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void PublishEvent(::grpc::ClientContext* context, const ::seshat::PublishEventRequest* request, ::seshat::PublishEventResponse* response, std::function<void(::grpc::Status)>) override;
      void PublishEvent(::grpc::ClientContext* context, const ::seshat::PublishEventRequest* request, ::seshat::PublishEventResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SubscribeToEvents(::grpc::ClientContext* context, const ::seshat::SubscribeRequest* request, ::grpc::ClientReadReactor< ::seshat::GameEvent>* reactor) override;
      void SubscribeToAllEvents(::grpc::ClientContext* context, const ::seshat::SubscribeAllRequest* request, ::grpc::ClientReadReactor< ::seshat::GameEvent>* reactor) override;
      void GetEventHistory(::grpc::ClientContext* context, const ::seshat::EventHistoryRequest* request, ::seshat::EventHistoryResponse* response, std::function<void(::grpc::Status)>) override;
      void GetEventHistory(::grpc::ClientContext* context, const ::seshat::EventHistoryRequest* request, ::seshat::EventHistoryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ClearEventHistory(::grpc::ClientContext* context, const ::seshat::ClearEventHistoryRequest* request, ::seshat::ClearEventHistoryResponse* response, std::function<void(::grpc::Status)>) override;
      void ClearEventHistory(::grpc::ClientContext* context, const ::seshat::ClearEventHistoryRequest* request, ::seshat::ClearEventHistoryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSubscriptions(::grpc::ClientContext* context, const ::seshat::GetSubscriptionsRequest* request, ::seshat::GetSubscriptionsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetSubscriptions(::grpc::ClientContext* context, const ::seshat::GetSubscriptionsRequest* request, ::seshat::GetSubscriptionsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Unsubscribe(::grpc::ClientContext* context, const ::seshat::UnsubscribeRequest* request, ::seshat::UnsubscribeResponse* response, std::function<void(::grpc::Status)>) override;
      void Unsubscribe(::grpc::ClientContext* context, const ::seshat::UnsubscribeRequest* request, ::seshat::UnsubscribeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::seshat::PublishEventResponse>* AsyncPublishEventRaw(::grpc::ClientContext* context, const ::seshat::PublishEventRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::PublishEventResponse>* PrepareAsyncPublishEventRaw(::grpc::ClientContext* context, const ::seshat::PublishEventRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::seshat::GameEvent>* SubscribeToEventsRaw(::grpc::ClientContext* context, const ::seshat::SubscribeRequest& request) override;
    ::grpc::ClientAsyncReader< ::seshat::GameEvent>* AsyncSubscribeToEventsRaw(::grpc::ClientContext* context, const ::seshat::SubscribeRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::seshat::GameEvent>* PrepareAsyncSubscribeToEventsRaw(::grpc::ClientContext* context, const ::seshat::SubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::seshat::GameEvent>* SubscribeToAllEventsRaw(::grpc::ClientContext* context, const ::seshat::SubscribeAllRequest& request) override;
    ::grpc::ClientAsyncReader< ::seshat::GameEvent>* AsyncSubscribeToAllEventsRaw(::grpc::ClientContext* context, const ::seshat::SubscribeAllRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::seshat::GameEvent>* PrepareAsyncSubscribeToAllEventsRaw(::grpc::ClientContext* context, const ::seshat::SubscribeAllRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::EventHistoryResponse>* AsyncGetEventHistoryRaw(::grpc::ClientContext* context, const ::seshat::EventHistoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::EventHistoryResponse>* PrepareAsyncGetEventHistoryRaw(::grpc::ClientContext* context, const ::seshat::EventHistoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::ClearEventHistoryResponse>* AsyncClearEventHistoryRaw(::grpc::ClientContext* context, const ::seshat::ClearEventHistoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::ClearEventHistoryResponse>* PrepareAsyncClearEventHistoryRaw(::grpc::ClientContext* context, const ::seshat::ClearEventHistoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetSubscriptionsResponse>* AsyncGetSubscriptionsRaw(::grpc::ClientContext* context, const ::seshat::GetSubscriptionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::GetSubscriptionsResponse>* PrepareAsyncGetSubscriptionsRaw(::grpc::ClientContext* context, const ::seshat::GetSubscriptionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::UnsubscribeResponse>* AsyncUnsubscribeRaw(::grpc::ClientContext* context, const ::seshat::UnsubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::seshat::UnsubscribeResponse>* PrepareAsyncUnsubscribeRaw(::grpc::ClientContext* context, const ::seshat::UnsubscribeRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_PublishEvent_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeToEvents_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeToAllEvents_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEventHistory_;
    const ::grpc::internal::RpcMethod rpcmethod_ClearEventHistory_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSubscriptions_;
    const ::grpc::internal::RpcMethod rpcmethod_Unsubscribe_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Publish an event to the bus
    virtual ::grpc::Status PublishEvent(::grpc::ServerContext* context, const ::seshat::PublishEventRequest* request, ::seshat::PublishEventResponse* response);
    // Subscribe to specific event types (streaming)
    virtual ::grpc::Status SubscribeToEvents(::grpc::ServerContext* context, const ::seshat::SubscribeRequest* request, ::grpc::ServerWriter< ::seshat::GameEvent>* writer);
    // Subscribe to all events (streaming)
    virtual ::grpc::Status SubscribeToAllEvents(::grpc::ServerContext* context, const ::seshat::SubscribeAllRequest* request, ::grpc::ServerWriter< ::seshat::GameEvent>* writer);
    // Get event history
    virtual ::grpc::Status GetEventHistory(::grpc::ServerContext* context, const ::seshat::EventHistoryRequest* request, ::seshat::EventHistoryResponse* response);
    // Clear event history
    virtual ::grpc::Status ClearEventHistory(::grpc::ServerContext* context, const ::seshat::ClearEventHistoryRequest* request, ::seshat::ClearEventHistoryResponse* response);
    // Get active subscriptions
    virtual ::grpc::Status GetSubscriptions(::grpc::ServerContext* context, const ::seshat::GetSubscriptionsRequest* request, ::seshat::GetSubscriptionsResponse* response);
    // Unsubscribe from events
    virtual ::grpc::Status Unsubscribe(::grpc::ServerContext* context, const ::seshat::UnsubscribeRequest* request, ::seshat::UnsubscribeResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_PublishEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PublishEvent() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_PublishEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishEvent(::grpc::ServerContext* /*context*/, const ::seshat::PublishEventRequest* /*request*/, ::seshat::PublishEventResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPublishEvent(::grpc::ServerContext* context, ::seshat::PublishEventRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::PublishEventResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeToEvents() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_SubscribeToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToEvents(::grpc::ServerContext* /*context*/, const ::seshat::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::seshat::GameEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeToEvents(::grpc::ServerContext* context, ::seshat::SubscribeRequest* request, ::grpc::ServerAsyncWriter< ::seshat::GameEvent>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeToAllEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeToAllEvents() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SubscribeToAllEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToAllEvents(::grpc::ServerContext* /*context*/, const ::seshat::SubscribeAllRequest* /*request*/, ::grpc::ServerWriter< ::seshat::GameEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeToAllEvents(::grpc::ServerContext* context, ::seshat::SubscribeAllRequest* request, ::grpc::ServerAsyncWriter< ::seshat::GameEvent>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEventHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEventHistory() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetEventHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventHistory(::grpc::ServerContext* /*context*/, const ::seshat::EventHistoryRequest* /*request*/, ::seshat::EventHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEventHistory(::grpc::ServerContext* context, ::seshat::EventHistoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::EventHistoryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ClearEventHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ClearEventHistory() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ClearEventHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearEventHistory(::grpc::ServerContext* /*context*/, const ::seshat::ClearEventHistoryRequest* /*request*/, ::seshat::ClearEventHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearEventHistory(::grpc::ServerContext* context, ::seshat::ClearEventHistoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::ClearEventHistoryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSubscriptions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSubscriptions() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetSubscriptions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSubscriptions(::grpc::ServerContext* /*context*/, const ::seshat::GetSubscriptionsRequest* /*request*/, ::seshat::GetSubscriptionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSubscriptions(::grpc::ServerContext* context, ::seshat::GetSubscriptionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::GetSubscriptionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Unsubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Unsubscribe() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_Unsubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unsubscribe(::grpc::ServerContext* /*context*/, const ::seshat::UnsubscribeRequest* /*request*/, ::seshat::UnsubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnsubscribe(::grpc::ServerContext* context, ::seshat::UnsubscribeRequest* request, ::grpc::ServerAsyncResponseWriter< ::seshat::UnsubscribeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_PublishEvent<WithAsyncMethod_SubscribeToEvents<WithAsyncMethod_SubscribeToAllEvents<WithAsyncMethod_GetEventHistory<WithAsyncMethod_ClearEventHistory<WithAsyncMethod_GetSubscriptions<WithAsyncMethod_Unsubscribe<Service > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_PublishEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PublishEvent() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::PublishEventRequest, ::seshat::PublishEventResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::PublishEventRequest* request, ::seshat::PublishEventResponse* response) { return this->PublishEvent(context, request, response); }));}
    void SetMessageAllocatorFor_PublishEvent(
        ::grpc::MessageAllocator< ::seshat::PublishEventRequest, ::seshat::PublishEventResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::PublishEventRequest, ::seshat::PublishEventResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PublishEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishEvent(::grpc::ServerContext* /*context*/, const ::seshat::PublishEventRequest* /*request*/, ::seshat::PublishEventResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PublishEvent(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::PublishEventRequest* /*request*/, ::seshat::PublishEventResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubscribeToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubscribeToEvents() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackServerStreamingHandler< ::seshat::SubscribeRequest, ::seshat::GameEvent>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::SubscribeRequest* request) { return this->SubscribeToEvents(context, request); }));
    }
    ~WithCallbackMethod_SubscribeToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToEvents(::grpc::ServerContext* /*context*/, const ::seshat::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::seshat::GameEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::seshat::GameEvent>* SubscribeToEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::SubscribeRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SubscribeToAllEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SubscribeToAllEvents() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::seshat::SubscribeAllRequest, ::seshat::GameEvent>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::SubscribeAllRequest* request) { return this->SubscribeToAllEvents(context, request); }));
    }
    ~WithCallbackMethod_SubscribeToAllEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToAllEvents(::grpc::ServerContext* /*context*/, const ::seshat::SubscribeAllRequest* /*request*/, ::grpc::ServerWriter< ::seshat::GameEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::seshat::GameEvent>* SubscribeToAllEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::SubscribeAllRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetEventHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetEventHistory() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::EventHistoryRequest, ::seshat::EventHistoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::EventHistoryRequest* request, ::seshat::EventHistoryResponse* response) { return this->GetEventHistory(context, request, response); }));}
    void SetMessageAllocatorFor_GetEventHistory(
        ::grpc::MessageAllocator< ::seshat::EventHistoryRequest, ::seshat::EventHistoryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::EventHistoryRequest, ::seshat::EventHistoryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetEventHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventHistory(::grpc::ServerContext* /*context*/, const ::seshat::EventHistoryRequest* /*request*/, ::seshat::EventHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEventHistory(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::EventHistoryRequest* /*request*/, ::seshat::EventHistoryResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ClearEventHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ClearEventHistory() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::ClearEventHistoryRequest, ::seshat::ClearEventHistoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::ClearEventHistoryRequest* request, ::seshat::ClearEventHistoryResponse* response) { return this->ClearEventHistory(context, request, response); }));}
    void SetMessageAllocatorFor_ClearEventHistory(
        ::grpc::MessageAllocator< ::seshat::ClearEventHistoryRequest, ::seshat::ClearEventHistoryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::ClearEventHistoryRequest, ::seshat::ClearEventHistoryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ClearEventHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearEventHistory(::grpc::ServerContext* /*context*/, const ::seshat::ClearEventHistoryRequest* /*request*/, ::seshat::ClearEventHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ClearEventHistory(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::ClearEventHistoryRequest* /*request*/, ::seshat::ClearEventHistoryResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSubscriptions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSubscriptions() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::GetSubscriptionsRequest, ::seshat::GetSubscriptionsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::GetSubscriptionsRequest* request, ::seshat::GetSubscriptionsResponse* response) { return this->GetSubscriptions(context, request, response); }));}
    void SetMessageAllocatorFor_GetSubscriptions(
        ::grpc::MessageAllocator< ::seshat::GetSubscriptionsRequest, ::seshat::GetSubscriptionsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::GetSubscriptionsRequest, ::seshat::GetSubscriptionsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSubscriptions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSubscriptions(::grpc::ServerContext* /*context*/, const ::seshat::GetSubscriptionsRequest* /*request*/, ::seshat::GetSubscriptionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSubscriptions(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::GetSubscriptionsRequest* /*request*/, ::seshat::GetSubscriptionsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Unsubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Unsubscribe() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::seshat::UnsubscribeRequest, ::seshat::UnsubscribeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::seshat::UnsubscribeRequest* request, ::seshat::UnsubscribeResponse* response) { return this->Unsubscribe(context, request, response); }));}
    void SetMessageAllocatorFor_Unsubscribe(
        ::grpc::MessageAllocator< ::seshat::UnsubscribeRequest, ::seshat::UnsubscribeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::seshat::UnsubscribeRequest, ::seshat::UnsubscribeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Unsubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unsubscribe(::grpc::ServerContext* /*context*/, const ::seshat::UnsubscribeRequest* /*request*/, ::seshat::UnsubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Unsubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::seshat::UnsubscribeRequest* /*request*/, ::seshat::UnsubscribeResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_PublishEvent<WithCallbackMethod_SubscribeToEvents<WithCallbackMethod_SubscribeToAllEvents<WithCallbackMethod_GetEventHistory<WithCallbackMethod_ClearEventHistory<WithCallbackMethod_GetSubscriptions<WithCallbackMethod_Unsubscribe<Service > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_PublishEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PublishEvent() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_PublishEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishEvent(::grpc::ServerContext* /*context*/, const ::seshat::PublishEventRequest* /*request*/, ::seshat::PublishEventResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeToEvents() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_SubscribeToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToEvents(::grpc::ServerContext* /*context*/, const ::seshat::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::seshat::GameEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeToAllEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeToAllEvents() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SubscribeToAllEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToAllEvents(::grpc::ServerContext* /*context*/, const ::seshat::SubscribeAllRequest* /*request*/, ::grpc::ServerWriter< ::seshat::GameEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEventHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEventHistory() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetEventHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventHistory(::grpc::ServerContext* /*context*/, const ::seshat::EventHistoryRequest* /*request*/, ::seshat::EventHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ClearEventHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ClearEventHistory() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ClearEventHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearEventHistory(::grpc::ServerContext* /*context*/, const ::seshat::ClearEventHistoryRequest* /*request*/, ::seshat::ClearEventHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSubscriptions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSubscriptions() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetSubscriptions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSubscriptions(::grpc::ServerContext* /*context*/, const ::seshat::GetSubscriptionsRequest* /*request*/, ::seshat::GetSubscriptionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Unsubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Unsubscribe() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_Unsubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unsubscribe(::grpc::ServerContext* /*context*/, const ::seshat::UnsubscribeRequest* /*request*/, ::seshat::UnsubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_PublishEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PublishEvent() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_PublishEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishEvent(::grpc::ServerContext* /*context*/, const ::seshat::PublishEventRequest* /*request*/, ::seshat::PublishEventResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPublishEvent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeToEvents() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_SubscribeToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToEvents(::grpc::ServerContext* /*context*/, const ::seshat::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::seshat::GameEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeToEvents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(1, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeToAllEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeToAllEvents() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SubscribeToAllEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToAllEvents(::grpc::ServerContext* /*context*/, const ::seshat::SubscribeAllRequest* /*request*/, ::grpc::ServerWriter< ::seshat::GameEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeToAllEvents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(2, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEventHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEventHistory() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetEventHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventHistory(::grpc::ServerContext* /*context*/, const ::seshat::EventHistoryRequest* /*request*/, ::seshat::EventHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEventHistory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ClearEventHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ClearEventHistory() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ClearEventHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearEventHistory(::grpc::ServerContext* /*context*/, const ::seshat::ClearEventHistoryRequest* /*request*/, ::seshat::ClearEventHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearEventHistory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSubscriptions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSubscriptions() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetSubscriptions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSubscriptions(::grpc::ServerContext* /*context*/, const ::seshat::GetSubscriptionsRequest* /*request*/, ::seshat::GetSubscriptionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSubscriptions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Unsubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Unsubscribe() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_Unsubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unsubscribe(::grpc::ServerContext* /*context*/, const ::seshat::UnsubscribeRequest* /*request*/, ::seshat::UnsubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnsubscribe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PublishEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PublishEvent() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PublishEvent(context, request, response); }));
    }
    ~WithRawCallbackMethod_PublishEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PublishEvent(::grpc::ServerContext* /*context*/, const ::seshat::PublishEventRequest* /*request*/, ::seshat::PublishEventResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PublishEvent(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubscribeToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubscribeToEvents() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->SubscribeToEvents(context, request); }));
    }
    ~WithRawCallbackMethod_SubscribeToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToEvents(::grpc::ServerContext* /*context*/, const ::seshat::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::seshat::GameEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeToEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SubscribeToAllEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SubscribeToAllEvents() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->SubscribeToAllEvents(context, request); }));
    }
    ~WithRawCallbackMethod_SubscribeToAllEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeToAllEvents(::grpc::ServerContext* /*context*/, const ::seshat::SubscribeAllRequest* /*request*/, ::grpc::ServerWriter< ::seshat::GameEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeToAllEvents(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetEventHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetEventHistory() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEventHistory(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetEventHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventHistory(::grpc::ServerContext* /*context*/, const ::seshat::EventHistoryRequest* /*request*/, ::seshat::EventHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetEventHistory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ClearEventHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ClearEventHistory() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ClearEventHistory(context, request, response); }));
    }
    ~WithRawCallbackMethod_ClearEventHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearEventHistory(::grpc::ServerContext* /*context*/, const ::seshat::ClearEventHistoryRequest* /*request*/, ::seshat::ClearEventHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ClearEventHistory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSubscriptions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSubscriptions() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSubscriptions(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSubscriptions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSubscriptions(::grpc::ServerContext* /*context*/, const ::seshat::GetSubscriptionsRequest* /*request*/, ::seshat::GetSubscriptionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSubscriptions(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Unsubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Unsubscribe() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Unsubscribe(context, request, response); }));
    }
    ~WithRawCallbackMethod_Unsubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unsubscribe(::grpc::ServerContext* /*context*/, const ::seshat::UnsubscribeRequest* /*request*/, ::seshat::UnsubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Unsubscribe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PublishEvent : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PublishEvent() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::PublishEventRequest, ::seshat::PublishEventResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::PublishEventRequest, ::seshat::PublishEventResponse>* streamer) {
                       return this->StreamedPublishEvent(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PublishEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PublishEvent(::grpc::ServerContext* /*context*/, const ::seshat::PublishEventRequest* /*request*/, ::seshat::PublishEventResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPublishEvent(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::PublishEventRequest,::seshat::PublishEventResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEventHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEventHistory() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::EventHistoryRequest, ::seshat::EventHistoryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::EventHistoryRequest, ::seshat::EventHistoryResponse>* streamer) {
                       return this->StreamedGetEventHistory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEventHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEventHistory(::grpc::ServerContext* /*context*/, const ::seshat::EventHistoryRequest* /*request*/, ::seshat::EventHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEventHistory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::EventHistoryRequest,::seshat::EventHistoryResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ClearEventHistory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ClearEventHistory() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::ClearEventHistoryRequest, ::seshat::ClearEventHistoryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::ClearEventHistoryRequest, ::seshat::ClearEventHistoryResponse>* streamer) {
                       return this->StreamedClearEventHistory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ClearEventHistory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ClearEventHistory(::grpc::ServerContext* /*context*/, const ::seshat::ClearEventHistoryRequest* /*request*/, ::seshat::ClearEventHistoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClearEventHistory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::ClearEventHistoryRequest,::seshat::ClearEventHistoryResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSubscriptions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSubscriptions() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::GetSubscriptionsRequest, ::seshat::GetSubscriptionsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::GetSubscriptionsRequest, ::seshat::GetSubscriptionsResponse>* streamer) {
                       return this->StreamedGetSubscriptions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSubscriptions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSubscriptions(::grpc::ServerContext* /*context*/, const ::seshat::GetSubscriptionsRequest* /*request*/, ::seshat::GetSubscriptionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSubscriptions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::GetSubscriptionsRequest,::seshat::GetSubscriptionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Unsubscribe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Unsubscribe() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::seshat::UnsubscribeRequest, ::seshat::UnsubscribeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::seshat::UnsubscribeRequest, ::seshat::UnsubscribeResponse>* streamer) {
                       return this->StreamedUnsubscribe(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Unsubscribe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Unsubscribe(::grpc::ServerContext* /*context*/, const ::seshat::UnsubscribeRequest* /*request*/, ::seshat::UnsubscribeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnsubscribe(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::seshat::UnsubscribeRequest,::seshat::UnsubscribeResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_PublishEvent<WithStreamedUnaryMethod_GetEventHistory<WithStreamedUnaryMethod_ClearEventHistory<WithStreamedUnaryMethod_GetSubscriptions<WithStreamedUnaryMethod_Unsubscribe<Service > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeToEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeToEvents() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::seshat::SubscribeRequest, ::seshat::GameEvent>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::seshat::SubscribeRequest, ::seshat::GameEvent>* streamer) {
                       return this->StreamedSubscribeToEvents(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SubscribeToEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeToEvents(::grpc::ServerContext* /*context*/, const ::seshat::SubscribeRequest* /*request*/, ::grpc::ServerWriter< ::seshat::GameEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeToEvents(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::seshat::SubscribeRequest,::seshat::GameEvent>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeToAllEvents : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeToAllEvents() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::seshat::SubscribeAllRequest, ::seshat::GameEvent>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::seshat::SubscribeAllRequest, ::seshat::GameEvent>* streamer) {
                       return this->StreamedSubscribeToAllEvents(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SubscribeToAllEvents() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeToAllEvents(::grpc::ServerContext* /*context*/, const ::seshat::SubscribeAllRequest* /*request*/, ::grpc::ServerWriter< ::seshat::GameEvent>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeToAllEvents(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::seshat::SubscribeAllRequest,::seshat::GameEvent>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_SubscribeToEvents<WithSplitStreamingMethod_SubscribeToAllEvents<Service > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_PublishEvent<WithSplitStreamingMethod_SubscribeToEvents<WithSplitStreamingMethod_SubscribeToAllEvents<WithStreamedUnaryMethod_GetEventHistory<WithStreamedUnaryMethod_ClearEventHistory<WithStreamedUnaryMethod_GetSubscriptions<WithStreamedUnaryMethod_Unsubscribe<Service > > > > > > > StreamedService;
};

}  // namespace seshat


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_seshat_2fevents_2eproto__INCLUDED
